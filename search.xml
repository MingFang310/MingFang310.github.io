<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成与体系结构</title>
      <link href="/2021/08/23/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/"/>
      <url>/2021/08/23/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/</url>
      
        <content type="html"><![CDATA[<p>自用的学习笔记，若有错误欢迎指出。</p><h2 id="数据的表示【4】"><a href="#数据的表示【4】" class="headerlink" title="数据的表示【4】"></a>数据的表示【4】</h2><h3 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h3><h4 id="按权展开法"><a href="#按权展开法" class="headerlink" title="按权展开法"></a>按权展开法</h4><p>R进制转十进制使用<strong>按权展开法</strong>，其具体操作方式为:将R进制数的每一位数值用$R^K$形式表示，即幂的底数是R,指数为k,k与该位和小数点之间的距离有关。当该位位于小数点左边，k值是该位和小数点之间数码的个数，而当该位位于小数点右边，k值是负值,其绝对值是该位和小数点之间数码的个数加1。</p><p>例如<strong>二进制</strong>：$10100.01 = 1 * 2^4 + 1 * 2^2 + 1 * 2^{-2}$</p><p>例如<strong>七进制</strong>：$604.01 = 6 * 7^2 + 4 * 7^0 + 1 * 7^{-2}$</p><p>二进制：0-1</p><p>十进制：0-9</p><p>十六进制：0-9，A-F（16进制数以大写’H’开头）</p><h4 id="短除法"><a href="#短除法" class="headerlink" title="短除法"></a>短除法</h4><p>十进制转R进制使用<strong>短除法</strong>，也称为<strong>除基取余法</strong>。</p><p><img src="/2021/08/23/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E7%9F%AD%E9%99%A4%E6%B3%95.png" alt="进制转换-短除法"></p><p><img src="/2021/08/23/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/%E7%9F%AD%E9%99%A4%E6%B3%95%E5%AE%9E%E4%BE%8B2.png" alt="短除法实例2"></p><p>将二进制转为<strong>八进制</strong>和<strong>十六进制</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#二进制转八进制##将二进制数从右往左分成每3个数码一组10 001 110#转换2   1   6#二进制转十六进制##将二进制数从右往左分成每4个数码一组1000 1110#转换  8   E<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：十六进制的1-15的表示方法</p><p><img src="/2021/08/23/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/1-15%E7%9A%84%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA.png" alt="1-15的十六进制表示"></p><h3 id="原码、反码、补码、移码"><a href="#原码、反码、补码、移码" class="headerlink" title="原码、反码、补码、移码"></a>原码、反码、补码、移码</h3><p><img src="/2021/08/23/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E7%A7%BB%E7%A0%81.png" alt="原码反码补码移码"></p><ul><li>原码：符号位表示正负，<code>0</code>表示<code>+</code>，<code>1</code>表示<code>-</code>。</li><li>反码：正数的反码和原码相同，负数按照各个<strong>数据位</strong>取反。</li><li>补码：正数的补码和原码相同，负数的补码按照其反码的基础上<code>+1</code>。</li><li>移码：在补码的基础上在<strong>符号位（首位）</strong>上取反。</li></ul><ul><li>正数：原码、反码、补码相同，移码在<strong>符号位（首位）</strong>上取反。</li><li>负数：<ul><li>反码：<strong>符号位</strong>不变，<strong>数据位</strong>取反。</li><li>补码：在<strong>反码</strong>的基础上<code>+1</code></li><li>移码：<strong>补码</strong>的基础上，<strong>符号位</strong>取反。</li></ul></li></ul><h3 id="数值表示范围"><a href="#数值表示范围" class="headerlink" title="数值表示范围"></a>数值表示范围</h3><p><img src="/2021/08/23/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/%E6%95%B0%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4.png" alt="数值的表示范围"></p><p>当<code>n = 8</code>,也就是一共8个数位时：</p><ul><li>定点整数：<ul><li>虽然是通过<code>+1</code>来实现了2^8，但是由于第一位是符号位，所以不显示，所以实际上<code>1000 0000</code>这个数无法显示出来。原码中正数和负数的数值表示范围为：$2^{n-1}$。同时，由于存在<code>-0</code>和<code>+0</code>这两个数（<code>1000 0000</code>&amp;<code>0000 0000</code>），所以在正数和负数那里分别将那个<code>-0</code>或者<code>+0</code>去掉，所以需要$2^{n-1} - 1$。</li><li><strong>原码</strong>表示范围：-127 ~ +127，转为二进制：<code>1111 1111</code> ~ <code>0111 1111</code>。</li><li><strong>补码</strong>表示范围：<code>1000 0000</code> ~ <code>0111 1111</code>。其中，<code>-128</code>的补码为<code>1 0000 0000</code>是<strong>人为规定</strong>的。</li></ul></li><li>定点小数：<ul><li>假设一个小数二进制表示：<code>0.111 1111</code>在加上<code>0.000 0001</code>就可以得到<code>1.000 0000</code>。同理，定点小数中的负数和正数的表示范围为：$+(1 - 2^{n-1})$~$-(1 - 2^{n-1})$。</li><li><strong>原码</strong>表示范围：<code>-0.111 1111</code> ~ <code>+0.111 1111</code>。</li><li><strong>补码</strong>表示范围：<code>-1</code> ~ <code>+0.111 1111</code>。其中，<code>-1</code>的补码为<code>1 0000 0000</code>是<strong>人为规定</strong>的。</li></ul></li></ul><p>注意：</p><ul><li><strong>原码</strong>和<strong>反码</strong>都存在<code>-0</code>和<code>+0</code>这两个数。</li><li>在补码中的<code>-128</code>和<code>-1</code>都是<strong>人为规定</strong>的。</li></ul><h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><p>浮点数表示：$N = 尾数 * 基数^{指数}$</p><p>运算过程：对阶 &gt; 尾数计算 &gt; 结果格式化</p><p>特点：</p><ol><li>一般尾数用补码，阶码用移码。</li><li><strong>阶码的位数</strong>决定数的<strong>表示范围</strong>，位数越多范围越大。</li><li><strong>尾数的位数</strong>决定数的<strong>有效精度</strong>，位数越多精度越高。</li><li>对阶时，<strong>小数向大数看齐</strong>。</li><li>对阶是通过<strong>较小的尾数右移</strong>实现的。</li></ol><p>实例：</p><p>$1.25 * 10^5 + 2.25 * 10^7$ ，我们需要将$1.25 * 10^5$转换为——&gt; $0.0125 * 10^7$，然后再进行运算为：$0.0125 * 10^5 + 2.25 * 10^7 = 2.2625 * 10^7$。</p><h2 id="运算器与控制器【4】"><a href="#运算器与控制器【4】" class="headerlink" title="运算器与控制器【4】"></a>运算器与控制器【4】</h2><p>计算机结构</p><p><img src="/2021/08/23/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="计算机结构"></p><p>运算器：</p><ol><li><strong>算术逻辑单元ALU：数据的算数运算和逻辑运算。【重要】</strong></li><li>累加寄存器AC：通用寄存器，为ALU提供一个工作区，用于暂存数据。【重要】</li><li>数据缓冲寄存器DR：写内存是，暂存指令或数据。</li><li>状态条件寄存器PSW：存状态标志与控制标志（<strong>争议：也有将其归为控制器</strong>）</li></ol><p>控制器：</p><ol><li><strong>程序计数器PC：存储下一条要执行指令的地址。【重要】</strong></li><li>指令寄存器IR：存储即将执行的指令。【重要】</li><li>指令译码器ID：对指令中的操作码字段进行分析解释。</li><li>时序部件：提供时序控制信号。</li></ol><h2 id="Flyuu分类法【2】"><a href="#Flyuu分类法【2】" class="headerlink" title="Flyuu分类法【2】"></a>Flyuu分类法【2】</h2><p>计算机体现结构分类-Flynn</p><ul><li><code>I</code>：指令流</li><li><code>D</code>：数据流</li><li><code>S</code>：单</li><li><code>M</code>：多</li></ul><table><thead><tr><th align="center">体系结构类型</th><th align="center">结构</th><th align="center">关键特性</th><th align="center">代表</th></tr></thead><tbody><tr><td align="center">单指令流单数据流SISD</td><td align="center">控制部分：一个；处理器：一个；主存模块：一个</td><td align="center"></td><td align="center">单处理器系统</td></tr><tr><td align="center">单指令流多数据流SIMD</td><td align="center">控制部分：一个；处理器：多个；主存模块：多个</td><td align="center">各处理器以异步的形式执行同一条指令</td><td align="center"><strong>并行处理机；阵列处理机；超级向量处理机</strong></td></tr><tr><td align="center">多指令流单数据流MISD</td><td align="center">控制部分：多个；处理器：一个；主存模块：多个</td><td align="center">被证明<strong>不可能</strong>，至少是不实际的</td><td align="center">目前没有，有文献称<strong>流水计算机</strong>为此类</td></tr><tr><td align="center">多指令流多数据流MIMD</td><td align="center">控制部分：多个；处理器：多个；主存模块：多个</td><td align="center">能够实现<strong>作业、任务、指令</strong>等各级全面并行</td><td align="center">多处理系统；多计算机</td></tr></tbody></table><h2 id="CISC与RISC【2】"><a href="#CISC与RISC【2】" class="headerlink" title="CISC与RISC【2】"></a>CISC与RISC【2】</h2><table><thead><tr><th>指令系统类型</th><th>指令</th><th>寻址方式</th><th>实现方式</th><th>其他</th></tr></thead><tbody><tr><td>CISC（复杂）</td><td>数量多，是有频率差别大，可变长格式</td><td>支持多种</td><td>微程序控制技术（微码）</td><td>研制周期长</td></tr><tr><td>RISC（精简）</td><td>数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有load/store操作内存</td><td>支持方式少</td><td>增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线</td><td>优化编译，有效支持高级语言。</td></tr></tbody></table><hr><p>CISC与RISC比较，分那些维度？</p><ul><li>指令数量、指令使用频率，寻址方式，寄存器，流水线支持，高级语言支持<ul><li>CISC：复杂，指令数量多，频率差别大，多寻址</li><li>RISC：精简，指令数量少，操作寄存器，单周期，少寻址，多通用寄存器，流水线</li></ul></li></ul><h3 id="指令的基本概念"><a href="#指令的基本概念" class="headerlink" title="指令的基本概念"></a>指令的基本概念</h3><p>每一条指令就是计算机语言的一个语句，它是一组有意义的二进制代码，指令的基本格式如下：</p><table><thead><tr><th>操作码字段</th><th>地址码字段</th></tr></thead></table><p>操作码部分指出了计算机要执行什么性质的操作，如加法、减法、取数、存数等。地址码字段需要包含各操作数的地址及操作结果的存放地址等，从其地址结构的角度可以分为三地址指令、二地址指令、一地址指令和零地址指令。</p><p>三地址指令</p><table><thead><tr><th>OP</th><th>A1</th><th>A2</th><th>A3</th></tr></thead></table><p>二地址指令</p><table><thead><tr><th>OP</th><th>A1</th><th>A2</th></tr></thead></table><p>一地址指令</p><table><thead><tr><th>OP</th><th>A1</th></tr></thead></table><p>零地址指令</p><table><thead><tr><th>OP</th></tr></thead></table><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul><li>立即寻址方式<ul><li>特点：操作数直接在指令中，速度快，灵活性差</li></ul></li><li>直接寻址方式<ul><li>特点：指令中存放的是操作数的地址</li></ul></li><li>间接寻址方式<ul><li>特点：指令中存放了一个地址，这个地址对应的内容是操作数的地址</li></ul></li><li>寄存器寻址方式<ul><li>特点：寄存器存放操作数</li></ul></li><li>寄存器间接寻址方式<ul><li>特点：寄存器内存放的是操作数的地址</li></ul></li></ul><h2 id="流水线技术【4】"><a href="#流水线技术【4】" class="headerlink" title="流水线技术【4】"></a>流水线技术【4】</h2><h3 id="流水线-概念"><a href="#流水线-概念" class="headerlink" title="流水线 - 概念"></a>流水线 - 概念</h3><p>相关参数计算：<strong>流水线执行时间计算</strong>、<strong>流水线吞吐率</strong>、流水线加速比、流水线效率</p><p>流水线是指在程序执行时<strong>多条指令重叠进行操作</strong>的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。</p><p><img src="/2021/08/23/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%A6%82%E5%BF%B5.png" alt="流水线概念"></p><h3 id="流水线-流水线计算"><a href="#流水线-流水线计算" class="headerlink" title="流水线 - 流水线计算"></a>流水线 - 流水线计算</h3><ul><li>流水线建立时间：流水线<strong>第一条指令</strong>完成的时间</li><li>流水线周期：分段之后，指令当中执行时间最长的一段。</li></ul><p>流水线计算公式为：</p><ul><li>1条指令执行时间 + （指令条数 - 1）* 流水线周期<ul><li>理论公式：(t1 + t2 + t3 +…+ tk) + (n - 1) * $\Delta t$</li><li>实践公式：k * $\Delta t$ + (n - 1) * $\Delta t$</li></ul></li></ul><p>(此处的$\Delta t$为流水线周期，而在题目中的$\Delta t$更多的指示的是单位时间)</p><p>例题：</p><ul><li>一条指令的执行过程可以分解为取指、分析和执行三步,在<strong>取指时间t</strong>取指=3$\Delta t$、<strong>分析时间t</strong>分析=2$\Delta t$、<strong>执行时间t</strong>执行=4$\Delta t$的情况下，若按<strong>串行方式（顺序执行）</strong>执行，则10条指令全部执行完需多少个$\Delta t$？<ul><li>由于是顺序执行，所以是求出一个指令建立的时间 * 全部指令个数</li><li>（3 + 2 + 4) * $\Delta t$ * 10 = 90$\Delta t$</li></ul></li></ul><ul><li><p>若按流水线的方式执行，流水线周期为多少个$\Delta t$？则10条指令全部执行完需要需多少个$\Delta t$？</p><ul><li>流水线周期不用特地计算，直接判断在完成指令的过程中花费最长时间的是哪一段就好。</li><li>我们可以看出<strong>执行时间t</strong>执行=4$\Delta t$，在整个执行指令的过程中花费了最多的时间。所以，<strong>流水线周期</strong>就为：4$\Delta t$</li><li>则10条指令全部执行完需要需多少个$\Delta t$：((3 + 2 + 4) + (10 - 1) * 4） * $\Delta t$ = 45$\Delta t$</li></ul></li><li><p>理论公式：(t1 + t2 + t3 +…+ tk) + （n - 1） * $\Delta t$</p></li></ul><p><img src="/2021/08/23/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%A1%E7%AE%97-%E7%90%86%E8%AE%BA%E5%85%AC%E5%BC%8F.png" alt="流水线计算-理论公式"></p><ul><li>实践公式：k * $\Delta t$ + (n - 1) * $\Delta t$</li></ul><p><img src="/2021/08/23/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%A1%E7%AE%97-%E5%AE%9E%E8%B7%B5%E5%85%AC%E5%BC%8F.png" alt="流水线计算-实践公式"></p><p>（<strong>注意：在选择题中，如果发现没有45$\Delta t$的选项出现的话，就需要套用实践公式来解题</strong>）</p><ul><li>这里的指令执行周期还是4$\Delta t$<ul><li>所以，套用公式：3 * 4$\Delta t$ + (10 - 1) * 4$\Delta t$ = 48$\Delta t$</li></ul></li></ul><h3 id="流水线-流水线吞吐率计算"><a href="#流水线-流水线吞吐率计算" class="headerlink" title="流水线-流水线吞吐率计算"></a>流水线-流水线吞吐率计算</h3><p>流水线的吞吐率(Though Put rate, TP)是指在<strong>单位时间内流水线所完成的任务数量或输出的结果数量</strong>。计算流水线吞吐率的最基本公式如下：<code>TP = 指令条数 / 流水线执行时间</code></p><p>流水线最大吞吐率：流水线最大吞吐率 = 流水线周期的倒数</p><p><img src="/2021/08/23/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%9C%80%E5%A4%A7%E5%90%9E%E5%90%90%E7%8E%87%E5%85%AC%E5%BC%8F.png" alt="流水线最大吞吐率公式"></p><h3 id="流水线-超标量流水线"><a href="#流水线-超标量流水线" class="headerlink" title="流水线-超标量流水线"></a>流水线-超标量流水线</h3><p><img src="/2021/08/23/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/%E6%B5%81%E6%B0%B4%E7%BA%BF-%E8%B6%85%E6%A0%87%E9%87%8F%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="流水线-超标量流水线"></p><p>新提出一个参数：<strong>度</strong>。</p><p><strong>度</strong>：指的是在某一时刻、某一个部件它可以同时处理的指令数量。</p><h2 id="存储系统【4】"><a href="#存储系统【4】" class="headerlink" title="存储系统【4】"></a>存储系统【4】</h2><h2 id="总线系统【1】"><a href="#总线系统【1】" class="headerlink" title="总线系统【1】"></a>总线系统【1】</h2><h2 id="可靠性【1】"><a href="#可靠性【1】" class="headerlink" title="可靠性【1】"></a>可靠性【1】</h2><h2 id="校验码【3】"><a href="#校验码【3】" class="headerlink" title="校验码【3】"></a>校验码【3】</h2>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件开发 </tag>
            
            <tag> 计算机组成 </tag>
            
            <tag> 数据的表示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记6-面向对象编程</title>
      <link href="/2021/07/17/java-xue-xi-bi-ji-6-mian-xiang-dui-xiang-bian-cheng/"/>
      <url>/2021/07/17/java-xue-xi-bi-ji-6-mian-xiang-dui-xiang-bian-cheng/</url>
      
        <content type="html"><![CDATA[<p>自用的学习笔记，若有错误欢迎指出。</p><h2 id="回顾方法以及加深"><a href="#回顾方法以及加深" class="headerlink" title="回顾方法以及加深"></a>回顾方法以及加深</h2><h3 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h3><ol><li><p>修饰符</p><ul><li><a href="https://www.runoob.com/java/java-modifier-types.html">菜鸟教程-传送门</a></li></ul></li><li><p>break和return的区别</p><ul><li>break：跳出switch循环，结速循环</li><li>return：代表方法的结束，返回一个结果</li></ul></li><li><p>方法名</p><ul><li>注意命名规范，要做到见名知意</li></ul></li><li><p>参数列表</p><ul><li>参数类型</li><li>参数名</li></ul></li></ol><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><ol><li><p>静态方法 static</p><ul><li><code>static</code>是和类一起加载的</li></ul></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;静态方法 staticpublic class Demo02&#123;    public static void main(String[] args)&#123;        &#x2F;&#x2F;实例化这个类 new        &#x2F;&#x2F;对象类型 对象名 &#x3D; 变量值        Student student &#x3D; new Student();        student.say();                    &#125;    &#125;&#x2F;&#x2F;这里在单独新创建一个类public class Student&#123;    &#x2F;&#x2F;定义一个方法    public void say()&#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>非静态方法</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo02&#123;    public static void main(String[] args)&#123;        &#x2F;&#x2F;实际参数和形式参数的类型要对应        Demo02 demo02 &#x3D; new Demo02();        demo02.add(1, 3);    &#125;    public int add(int a, int b)&#123;            return a + b;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="java值传递"><a href="#java值传递" class="headerlink" title="java值传递"></a>java值传递</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo04&#123;    public static void main(String[] args)&#123;        int a &#x3D; 1;        System.out.println(a);                Demo04.change(a);        System.out.println(a);&#x2F;&#x2F;输出值为：1    &#125;        &#x2F;&#x2F;返回值为空    public static void change(int a)&#123;        a &#x3D; 10;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Java引用传递"><a href="#Java引用传递" class="headerlink" title="Java引用传递"></a>Java引用传递</h3><p>引用传递的是对象，其本质还是值传递</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo01 &#123;    public static void main(String[] args) &#123;        Student student &#x3D; new Student();        System.out.println(student.name); &#x2F;&#x2F;null        Demo01.change(student);        System.out.println(student.name); &#x2F;&#x2F;Ben    &#125;    public static void change(Student student)&#123;        &#x2F;*student是一个对象        是指向的Student student &#x3D; new Student();        这个是一个具体的人，可以改变属性。        *&#x2F;        student.name &#x3D; &quot;Ben&quot;;    &#125;&#125;&#x2F;&#x2F;定义了一个Student类，有一个属性：nameclass Student&#123;    String name; &#x2F;&#x2F;null&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h2><ul><li>类似一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表某一个具体的事物。<ul><li>Person类、Pet类、Car类等，这些类都是用来描述/定义某一类具体的事物应该具备的特点和行为。</li></ul></li><li>对象是抽象概念的具体实例<ul><li>能够体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。</li><li>张三就是一个人的具体实例，张三家里的旺财就是狗的一个具体实例。</li></ul></li></ul><h2 id="创建与初始化对象"><a href="#创建与初始化对象" class="headerlink" title="创建与初始化对象"></a>创建与初始化对象</h2><ul><li>使用<code>new</code>关键字来创建对象</li><li>使用<code>new</code>关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中的构造器的调用。</li><li>类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点：<ul><li>必须和类的名字相同</li><li>必须没有返回类型，也不能写<code>void</code></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;一个项目应该只存在一个main方法public class Application &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;类是抽象的，需要实例化        &#x2F;&#x2F;类实例化后会返回一个自己的对象        Student josh &#x3D; new Student();        Student tom &#x3D; new Student();        &#x2F;&#x2F;赋值        josh.name &#x3D; &quot;josh&quot;;        josh.age &#x3D; 23;        System.out.println(josh.name); &#x2F;&#x2F;josh        System.out.println(josh.age); &#x2F;&#x2F;23    &#125;&#125;public class Student &#123;    &#x2F;&#x2F;属性：字段    String name; &#x2F;&#x2F;null    int age; &#x2F;&#x2F;0    &#x2F;&#x2F;方法    public void study()&#123;        System.out.println(this.name + &quot;在学习中&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul><li>使用<code>new</code>关键字，必须要有构造器。其本质是在调用构造器。</li><li>有参构造：一旦定义了有参构造，无参就必须显示定义</li><li>构造器的定义：<ul><li>和类名字相同</li><li>没有返回值</li></ul></li><li>构造器的作用：<ul><li><code>new</code>本质在调用构造器</li><li>初始化对象的值</li></ul></li><li>注意：<ul><li>定义了有参构造器，如果想使用无参构造，需要去定义一个无参数的构造器</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Application &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;new 实例化一个对象        Person person &#x3D; new Person();        System.out.println(person.name); &#x2F;&#x2F;josh    &#125;&#125;public class Person &#123;    String name;        &#x2F;&#x2F;这是一个无参构造器    public Person（）&#123;            &#125;    &#x2F;&#x2F;实例化初始值    public Person()&#123;        this.name &#x3D; &quot;josh&quot;;    &#125;    &#x2F;&#x2F;idea：alt + insert可以自动生成构造器&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="面向过程-amp-面向对象"><a href="#面向过程-amp-面向对象" class="headerlink" title="面向过程 &amp; 面向对象"></a>面向过程 &amp; 面向对象</h2><ul><li>面向过程思想<ul><li>步骤清晰简单</li><li>面对过程适合处理一些较为简单的问题</li></ul></li><li>面向对象思想<ul><li>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。</li><li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题。</li></ul></li><li><strong>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</strong></li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul><li>面向对象编程(Object-Oriented Programming，OOP)</li><li>面向对象编程的本质就是：<strong>以类的方式组装代码，以对象的组织(封装)数据</strong></li><li>抽象</li><li>三大特性<ul><li><strong>封装</strong></li><li><strong>继承</strong></li><li><strong>多态</strong></li></ul></li></ul><p>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</p><p>从代码运行角度考虑是先有类后有对象。类是对象的模板。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>我们程序设计要追求：“<strong>高内聚，低耦合</strong>”。<strong>高内聚</strong>就是类的内部数据操作细节自己完成，不允许外部干涉；<strong>低耦合</strong>就是仅暴露少量的方法给外部使用。</p><ul><li>封装（数据的隐藏）<ul><li>通常，应该禁止直接访问一个对象中数据的实际表示，而应该通过操作接口来访问，这称为信息隐藏。</li><li><strong>属性私有：get/set</strong></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Application&#123;    public static void main(String[] args)&#123;        Student s1 &#x3D; new Student();                &#x2F;&#x2F;使用set方法        s1.setName(&quot;josh&quot;);        &#x2F;&#x2F;使用get方法        System.out.println(s1.getName());                s1.setAge(23);        System.out.println(s1.getAge());    &#125;&#125;&#x2F;&#x2F;idea中，使用快捷键：alt+insert快速生成get&#x2F;set方法public class Student&#123;    &#x2F;&#x2F;属性私有    private String name;    private int age;    private char sex;        &#x2F;&#x2F;提供一些可以操作这些属性的方法    &#x2F;&#x2F;提供可以允许被其他类调用的get和set方法        &#x2F;&#x2F;get获得这个数据    public String getName()&#123;        return this.name;    &#125;        &#x2F;&#x2F;set给这个数据设置值    public void setName(String name)&#123;        this.name &#x3D; name;    &#125;        public int getAge()&#123;        return this.age;    &#125;    public void setAge(int age)&#123;        if(age &gt; 120 || age &lt; 0)&#123;            System.out.println(&quot;你输入的年龄有误&quot;);        &#125; else &#123;            this.age &#x3D; age;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>封装的意义：</strong><ul><li>提高程序的安全性，保护数据</li><li>隐藏代码的实现细节</li><li>统一接口</li><li>提高了系统的可维护性</li></ul></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</p><ul><li><code>extends</code>的意思是“扩展”，子类是父类的扩展。</li><li>java中类只有单继承，没有多继承</li></ul><ul><li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。</li><li>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字<code>extends</code>来表示。</li><li>子类和父类之间，子类继承父类：<code>subClass extends superClass</code>。</li></ul><ul><li>object类</li><li>super</li><li>方法重写</li></ul><p>子类继承了父类，就会有父类的全部方法。</p><p>在java中，所有的类都默认直接或间接继承Object类</p><p><strong>注意点：</strong></p><ul><li><code>super</code>调用父类的构造方法，<strong>必须</strong>在构造方法的<strong>第一个</strong></li><li><code>super</code>必须只能出现在子类的方法或者构造方法中</li><li><code>super</code>和<code>this</code>不能同时调用构造方法</li></ul><p><strong><code>super</code>和<code>this</code>的区别：</strong></p><ul><li>代表的对象不同<ul><li><code>this</code>为本身调用者这个对象</li><li><code>super</code>代表父类对象的引用</li></ul></li><li>前提：<ul><li><code>this</code>没有继承也可以使用</li><li><code>super</code>只能在继承条件下使用</li></ul></li><li>构造方法：<ul><li><code>this();</code>在本类里面的构造</li><li><code>super();</code>父类的构造</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Application&#123;    public static void main(String[] args)&#123;        Student student &#x3D; new Student();        student.speak(); &#x2F;&#x2F;say hello        System.out.println(student.money); &#x2F;&#x2F;10000                &#x2F;*        *分别输出：        *Ben        *fm        *josh        *&#x2F;        student.test(&quot;Ben&quot;);                &#x2F;*        *分别输出：        *Student        *Student        *Person        *&#x2F;        student.test1();    &#125;&#125;&#x2F;&#x2F;Person类为父类&#x2F;&#x2F;在java中，所有的类都默认直接或间接继承Object类public class Person&#123;    public int money &#x3D; 10000;    protected String name &#x3D; &quot;josh&quot;;         public void speak()&#123;        System.out.println(&quot;say hello&quot;);    &#125;        public void print()&#123;        System.out.println(&quot;Person&quot;);    &#125;&#125;&#x2F;&#x2F;Student作为子类来继承父类Person&#x2F;&#x2F;子类继承了父类，就会有父类的全部方法public class Student extends Person&#123;    private String name &#x3D; &quot;fm&quot;;        public void test(String name)&#123;        System.out.println(name); &#x2F;&#x2F;访问参数name        System.out.println(this.name); &#x2F;&#x2F;访问Student类里面的name        System.out.println(super.name); &#x2F;&#x2F;访问父类Person类里面的name    &#125;    public void print()&#123;        System.out.println(&quot;Student&quot;);    &#125;        public void test1(String name)&#123;        print();        this.print();        super.print();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><ul><li>重写都是方法的重写，和属性无关</li><li><strong>静态</strong>方法和<strong>非静态</strong>方法的区别很大！</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Application&#123;    public static void main(String[] args)&#123;                A a &#x3D; new A();        a.test(); &#x2F;&#x2F;A-&gt;test()                &#x2F;&#x2F;方法的调用只和左边，定义的数据类型有关        &#x2F;&#x2F;父类的引用指向类子类        B b &#x3D; new A();        b.test(); &#x2F;&#x2F;B-&gt;test()    &#125;&#125;public class B&#123;    public static void test()&#123;        System.out.println(&quot;B-&gt;test()&quot;);    &#125;&#125;public class A extends B&#123;        public static void test()&#123;        System.out.println(&quot;A-&gt;test()&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们使用<code>@Override</code>来重写，可以看到子类重写了父类的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Application&#123;    public static void main(String[] args)&#123;                A a &#x3D; new A();        a.test(); &#x2F;&#x2F;A-&gt;test()                &#x2F;&#x2F;子类重写了父类的方法        B b &#x3D; new A();        b.test(); &#x2F;&#x2F;B-&gt;test()    &#125;&#125;public class B&#123;    public static void test()&#123;        System.out.println(&quot;B-&gt;test()&quot;);    &#125;&#125;public class A extends B&#123;        @Override &#x2F;&#x2F;重写，附带有功能的注释    public void test()&#123;        System.out.println(&quot;A-&gt;test()&quot;);    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重写需要有<strong>继承</strong>关系，子类重写的是父类的方法。</p><ol><li>方法名必须相同</li><li>参数列表必须相同</li><li>修饰符：范围可以扩大，不能缩小。（如果父类的是<code>public</code>，我们把它变成<code>private</code>就不行 （<code>public</code> &gt; <code>protected</code> &gt; <code>default</code> &gt; <code>private</code>））</li><li>抛出异常：范围可以被缩小，但不能扩大。</li><li>子类的方法必须和父类的一致，但是方法体不同。</li></ol><p>为什么需要重写：</p><ol><li>父类的功能，子类不一定需要，或者不一定满足。</li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态即同一个方法可以根据可以根据发送对象的不同而采用多种不同的行为方式。</p><p>一个对象的实际类型是确定的，但可以指向对象的引用类型有很多</p><ul><li>多态存在的条件<ul><li>有<strong>继承</strong>关系</li><li>子类重写父类方法</li><li>父类引用指向子类对象</li></ul></li><li>多态注意事项：<ul><li>多态是方法的多态，属性没有多态</li><li>父类和子类必须要有联系，不是同一类型进行转换就会报错（类型转换异常：<code>ClassCastException</code>）</li><li>无法实现多态：<ul><li><code>static</code>方法，这个是属于类，它不属于实例</li><li><code>final</code>常量</li><li><code>private</code>方法</li></ul></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Application&#123;    public static void main(String[] args)&#123;        &#x2F;&#x2F;一个对象的实际类型是确定的        &#x2F;&#x2F;可以指向的引用类型是不确定的        &#x2F;&#x2F;Student能调用的方法，都是自己的，或者是父类的方法        Student s1 &#x3D; new Student();        Student s2 &#x3D; new Student();                &#x2F;&#x2F;父类的引用指向子类        &#x2F;&#x2F;父类型不能调用子类独有的方法        Person s3 &#x3D; new Student();        Object s4 &#x3D; new Student();                &#x2F;*        * 对象能执行哪些方法，主要看对象在左边的类型        * 和右边关系不大。        *&#x2F;        s3.run(); &#x2F;&#x2F;子类重写了父类的方法，执行子类的方法，输出结果为：play        s1.run(); &#x2F;&#x2F;play    &#125;&#125;public class Person&#123;    public void run()&#123;        System.out.println(&quot;run&quot;);    &#125;&#125;public class Student extends Person&#123;    @Override     public void run()&#123;        System.out.println(&quot;play&quot;);    &#125;        public void eat()&#123;        System.out.println(&quot;eat&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="instanceof-关键词"><a href="#instanceof-关键词" class="headerlink" title="instanceof 关键词"></a><code>instanceof</code> 关键词</h4><p>在<code>instanceof</code>关键字中用来判断类和类之间是否拥有父子关系。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Application &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;Object &gt; String        &#x2F;&#x2F;Object &gt; Person &gt; Teacher        &#x2F;&#x2F;Object &gt; Person &gt; Student        Object object &#x3D; new Student();        System.out.println(object instanceof Person); &#x2F;&#x2F;true        System.out.println(object instanceof Student); &#x2F;&#x2F;true        System.out.println(object instanceof Object); &#x2F;&#x2F;true        System.out.println(object instanceof Teacher); &#x2F;&#x2F;false        System.out.println(object instanceof String); &#x2F;&#x2F;false        &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;                Person person &#x3D; new Student();        System.out.println(person instanceof Object); &#x2F;&#x2F;true        System.out.println(person instanceof Student); &#x2F;&#x2F;true        System.out.println(person instanceof Person); &#x2F;&#x2F;true        System.out.println(person instanceof Teacher); &#x2F;&#x2F;false    &#125;&#125;public class Person &#123;&#125;public class Student extends Person&#123;&#125;public class Teacher extends Person&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意点：</strong></p><ol><li>父类引用指向子类的对象。</li><li>把<strong>子类</strong>转换为<strong>父类</strong>，向上转型，可以<strong>直接转换</strong>。</li><li>把<strong>父类</strong>转换为<strong>子类</strong>，向下转型，需要进行<strong>强制转换</strong>。</li><li>进行转换是为了方便方法的调用，减少重复的代码，保证了代码的简洁。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Application &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;类型之间的转换：父类   子类        &#x2F;&#x2F;高                   低        Person student &#x3D; new Student();&#x2F;&#x2F;        student.go(); &#x2F;&#x2F;会编译报错        &#x2F;&#x2F;将这个对象转换为student类型，我们才可以使用student类型的方法了        &#x2F;&#x2F;高等级转换为低等级的需要强制转换        Student student1 &#x3D; (Student)student;        student1.play(); &#x2F;&#x2F;强制转换后可以使用        &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;                Student student &#x3D; new Student();        student.play();        &#x2F;&#x2F;子类转换为父类，可能会丢失自己本来的一些方法        Person person &#x3D; student;&#x2F;&#x2F;        person.play(); &#x2F;&#x2F;编译失败    &#125;&#125;public class Person &#123;    public void run()&#123;        System.out.println(&quot;run&quot;);    &#125;&#125;public class Student extends Person&#123;    public void play()&#123;        System.out.println(&quot;play&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="static关键字详解"><a href="#static关键字详解" class="headerlink" title="static关键字详解"></a>static关键字详解</h3><p>关于<code>static</code>关键字的小结</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;staticpublic class Student &#123;    private static int age;    private double score;    public static void main(String[] args) &#123;        Student s1 &#x3D; new Student();        System.out.println(Student.age); &#x2F;&#x2F;这个是类变量        System.out.println(s1.score);        System.out.println(s1.age);        Student.go(); &#x2F;&#x2F;静态方法可以直接调用        s1.run(); &#x2F;&#x2F;要调用非静态方法需要new    &#125;    public void run()&#123;        run(); &#x2F;&#x2F;非静态方法可以直接调用静态方法    &#125;    public static void go()&#123;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实一个类里面还存在有一个匿名代码块。同时，需要注意的是在类里面每一个代码块的加载时间是不同的。从上到下分别是：</p><ol><li><code>static代码块</code>是和类一起加载的，同时也是加载速度最快的。并且该代码块也只能执行一次。</li><li><code>匿名代码块</code>是可以用来赋予初始值的，为第二个被加载。</li><li>构造方法，最后被加载。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person &#123;    public static void main(String[] args) &#123;        Person p1 &#x3D; new Person();        Person p2 &#x3D; new Person();    &#125;    &#x2F;&#x2F;2：赋予初始值    &#123;        System.out.println(&quot;匿名代码块&quot;);    &#125;    &#x2F;&#x2F;1：和类一起加载的，第一个被加载。并且也只执行一次    static &#123;        System.out.println(&quot;静态代码块&quot;);    &#125;    &#x2F;&#x2F;3    public Person()&#123;        System.out.println(&quot;构造方法&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li><code>abstract</code>修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法；如果修饰类，那么该类就是抽象类。</li><li>抽象类可以没有抽象方法，但是抽象方法的类一定要申明为抽象类。</li><li>抽象类不能使用<code>new</code>关键字来创建对象，它是用来让子类继承的。</li><li>抽象方法，只有方法的申明，没有方法的实现，它是用来让子类去实现的。</li><li>子类继承抽象类，那么就必须要去实现抽象类中没有实现的抽象方法，否则该子类也要去申明为抽象类。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;abstract抽象类&#x2F;&#x2F;抽象类中可以写普通方法&#x2F;&#x2F;抽象方法必须在抽象类中&#x2F;&#x2F;抽象的抽象：约束public abstract class Action &#123;    &#x2F;&#x2F;抽象方法：只有方法名字，没有方法的实现    &#x2F;&#x2F;抽象类不能被new出来，只能靠子类去实现它    public abstract void doSomeThing();&#125;&#x2F;&#x2F;抽象类的所有方法，继承了它的子类，都必须要实现它的方法&#x2F;&#x2F;除非子类也是抽象类public class A extends Action&#123;    &#x2F;&#x2F;如果有一个类要继承抽象类，就必须要重写doSomeThing()方法    @Override    public void doSomeThing()&#123;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思考？：</p><ul><li>抽象类不能<code>new</code>对象出来，所以抽象类不存在构造器。</li><li>抽象类的存在是为了方便，提高了开发的效率。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>“面向接口的编程”</p><ul><li>普通类：只有具体实现</li><li>抽象类：具体实现和规范（抽象方法）都有</li><li>接口：只有规范</li></ul><ul><li>接口就是规范，定义的是一组规则。体现了现实世界中：“如果你是…就必须去…”的思想。比如：如果你是猎人，就必须去打猎。</li><li>接口的本质是契约，就像我们的法律一样。制定好后，大家就都要去遵守。</li><li>OO的精髓，是对对象的抽象，最能体现这一特点的就是接口。为什么我们去讨论所谓的设计模式都是只针对具备有抽象能力的语言比如说：<code>C++</code>、<code>java</code>、<code>C#</code>等，就是因为我们所研究的设计模式就是去研究如何合理的使用接口。</li></ul><p>声明类的关键字是<code>class</code>，声明接口的关键字是<code>interface</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;接口都需要用实现类&#x2F;&#x2F;implements 关键字public class UserServiceImpl implements UserService, TimeService&#123;    &#x2F;&#x2F;实现了接口的类就需要重写接口中的方法。    @Override    public void add(String addName) &#123;    &#125;    @Override    public void delete(String deleteName) &#123;    &#125;    @Override    public void update(String updateName) &#123;    &#125;    @Override    public void search(String searchName) &#123;    &#125;    @Override    public void timer() &#123;    &#125;&#125;&#x2F;&#x2F;接口都需要用实现类public interface UserService &#123;    &#x2F;&#x2F;在接口里面定义的属性都是常量    &#x2F;&#x2F;public static final int AGE &#x3D; 22;    int AGE &#x3D; 22;    &#x2F;&#x2F;接口中的所有定义的方法都是抽象的 abstract    void add(String addName);    void delete(String deleteName);    void update(String updateName);    void search(String searchName);&#125;public interface TimeService &#123;    void timer();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口的作用：</p><ol><li>约束。</li><li>定义一些方法，让不同的人来使用。</li><li>在接口里面所定义的方法都是<code>public abstract</code>。</li><li>在接口里面定义的变量都是常量：<code>public static final</code>。</li><li>接口不能被直接实例化，接口中没有构造方法。</li><li>关键字<code>implements</code>可以实现多个接口。</li><li>必须要重写接口中的方法<code>@Override</code>。</li></ol><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li>内部类就是在一个类的内部在定义一个类，比如在A类中定义一个B类，那么B类就相对与A类来说就是内部类，而A类相对于B类来说就是外部类了。</li><li>成员内部类</li><li>静态内部类</li><li>局部内部类</li><li>匿名内部类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Outer &#123;    private int id &#x3D; 207;    public int age;    public void out()&#123;        System.out.println(&quot;这是内部类的方法&quot;);    &#125;    public class Inner&#123;        public void in()&#123;            System.out.println(&quot;这是内部类&quot;);        &#125;        public void getId()&#123;            System.out.println(&quot;获得外部类的私有属性&quot;);            System.out.println(id);        &#125;    &#125;    &#125;public class Application &#123;    public static void main(String[] args) &#123;        Outer outer &#x3D;new Outer();        &#x2F;&#x2F;通过这个外部类来实例化内部类        Outer.Inner inner &#x3D; outer.new Inner();        inner.in();        inner.getId();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类可以写在多个地方</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Outer &#123;    public void method()&#123;        &#x2F;&#x2F;局部内部类        class Inner&#123;            public static void main(String[] args) &#123;                System.out.println(&quot;在方法中也可以加入class&quot;);            &#125;        &#125;    &#125;&#125;&#x2F;&#x2F;一个java类里面只能有一个public类，但是可以有多个class类class Test&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个是匿名内部类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Outer &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;没有名字初始化类,不用将实例保存在变量中        new Test().run();        new UserService()&#123;            @Override            public void say()&#123;                System.out.println(&quot;say hello&quot;);            &#125;        &#125;;    &#125;&#125;&#x2F;&#x2F;一个java类里面只能有一个public类，但是可以有多个class类class Test&#123;    public void run()&#123;        System.out.println(&quot;run&quot;);    &#125;&#125;interface UserService&#123;    void say();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>之后就是java中最重要的面向对象编程。加油！去吧，继续服务。 ( ﾟ ▽ ﾟ)つ□乾杯～</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>B站：<a href="https://www.bilibili.com/video/BV12J41137hu?p=76&share_source=copy_web">狂神说java</a>老师讲的真的非常好，有兴趣的话就去看看吧。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学笔记 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记5-数组</title>
      <link href="/2021/07/15/java-xue-xi-bi-ji-5-shu-zu/"/>
      <url>/2021/07/15/java-xue-xi-bi-ji-5-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>自用的学习笔记，若有错误欢迎指出。</p><h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><ul><li>数组是相同类型数据的有序集合。</li><li>数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。</li><li>其中，每一饿数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们。</li></ul><p>首先，必须声明数组变量，才能在程序中使用数组。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;首选方案dataType[] &#x3D; arrayRefVar;&#x2F;&#x2F;效果相同，但不是首选方案dataType &#x3D; arrayRefVar[];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Java语言使用new操作符来创建数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">dataType[] arrayRefVar &#x3D; new dataType[arraySize];int[] nums &#x3D; new int[10];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>数组的元素是通过索引访问的，数组索引从0开始。</p><p>获取数组长度<code>arrays.length</code>。</p><h2 id="数组的四个基本特点"><a href="#数组的四个基本特点" class="headerlink" title="数组的四个基本特点"></a>数组的四个基本特点</h2><ul><li><strong>其长度是确定的</strong>。数组一但被创建，它的大小就是不可以改变的。</li><li>其元素必须是<strong>相同类型</strong>，不允许出现混合类型。</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</li><li>数组变量属于引用类型，数组也可以看成是对象，数组中的每一个元素相当于该对象的成员变量。<strong>数组本身就是对象</strong>，java中的对象是在堆中的，因此数组无论是保存原始类型还是其他对象类型，<strong>数组对象本身实在堆中的</strong>。</li><li>数组下标的合法区间：[0, length - 1], 如果越界就会报错；</li></ul><h2 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用"></a>数组使用</h2><ul><li>普通的<code>for</code>循环</li><li><code>for - each</code>循环</li><li>数组作为方法入参</li><li>数组作为返回值</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[] arrays &#x3D; &#123;1, 2, 3, 4, 5&#125;;&#x2F;&#x2F;打印全部数组元素for (int i &#x3D; 0; i &lt; arrays.length; i++) &#123;    System.out.println(arrays[i]);&#125;&#x2F;&#x2F;计算所有元素的和System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);int sum &#x3D; 0;for (int i &#x3D; 0; i &lt; arrays.length; i++) &#123;    sum +&#x3D; arrays[i];&#125;System.out.println(sum);&#x2F;&#x2F;查找数组最大的元素int max &#x3D; 0;for (int i &#x3D; 0; i &lt; arrays.length; i++) &#123;    if (max &lt; arrays[i])&#123;        max &#x3D; arrays[i];    &#125;&#125;System.out.println(max);&#x2F;&#x2F;增强型for循环System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);for (int arrays: arrays) &#123;    System.out.println(arrays);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组可以封装成参数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo01 &#123;    public static void main(String[] args) &#123;        int[] arrays &#x3D; &#123;1, 2, 3, 4, 5, 6&#125;;        printMax(arrays);    &#125;    public static void printMax(int[] arrays)&#123;        int sum &#x3D; 0;        for (int i &#x3D; 0; i &lt; arrays.length; i++) &#123;            if (sum &lt; arrays[i])&#123;                sum &#x3D; arrays[i];            &#125;        &#125;        System.out.println(&quot;数组最大值为：&quot; + sum);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尝试使数组反转</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo01 &#123;    public static void main(String[] args) &#123;        int[] arrays &#x3D; &#123;1, 2, 3, 4, 5, 6&#125;;        int[] reverse &#x3D; reverse(arrays);        printArray(reverse);    &#125;    &#x2F;&#x2F;反转数组    public static int[] reverse(int[] arrays)&#123;        int[] result &#x3D; new int[arrays.length];        for (int i &#x3D; 0, j &#x3D; result.length - 1; i &lt; arrays.length; i++, j--) &#123;            result[j] &#x3D; arrays[i];        &#125;        return result;    &#125;    &#x2F;&#x2F;打印数组    public static void printArray(int[] arrays)&#123;        int result &#x3D; 0;        for (int i &#x3D; 0; i &lt; arrays.length; i++) &#123;            result &#x3D; arrays[i];            System.out.println(result);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组可以看作是数组的数组，比如二维度数组就是一个特殊的一维数组，其中每一个元素都是一个一维数组。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;二维数组int a[][] &#x3D; new int[3][9];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/07/15/java-xue-xi-bi-ji-5-shu-zu/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84.png" alt="多维数组"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[][] arrays &#x3D; &#123;&#123;1,2&#125;, &#123;2,3&#125;,&#123;3,4&#125;,&#123;4,5&#125;&#125;;for (int i &#x3D; 0; i &lt; arrays.length; i++) &#123;    for (int j &#x3D; 0; j &lt; arrays[i].length; j++)&#123;        System.out.println(arrays[i][j]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><ul><li>数组的工具类java.util.Arrays</li><li>由于数组对象本身并没有什么方法供我们调用，但是API中提供了一个工具类Arrays来供我们使用，从而可以对数据对象进行一些基本操作。</li><li><strong>查看JDK帮助文档</strong></li><li>Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名来进行调用，而“<strong>不用</strong>”使用对象来调用(注意：是<strong>不用</strong>，而不是不能使用)</li></ul><p>具有以下常用功能：</p><ul><li>给数组赋值：通过<code>fill</code>方法</li><li>对数组排序：通过<code>sort</code>方法，按照升序排列</li><li>比较数组：通过<code>equals</code>方法来比较数组中元素的值是否相等</li><li>查找数组元素：通过<code>binarySearch</code>方法能对排序好的数组进行二分查找法操作。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;public class Demo02 &#123;    public static void main(String[] args) &#123;        int[] arrays &#x3D; &#123;1, 23, 454, 342, 55, 8848, 367, 365, 9656&#125;;        &#x2F;&#x2F;比较来看，输出结果是一样的        System.out.println(Arrays.toString(arrays));        printArrays(arrays);                &#x2F;&#x2F;Arrays.sort();排序数组        Arrays.sort(arrays);        System.out.println();        System.out.println(Arrays.toString(arrays));    &#125;    &#x2F;&#x2F;实际作用原理    public static void printArrays(int[] arrays)&#123;        for (int i &#x3D; 0; i &lt; arrays.length; i++)&#123;            if (i &#x3D;&#x3D; 0)&#123;                System.out.print(&quot;[&quot;);            &#125;            if (i &#x3D;&#x3D; arrays.length - 1)&#123;                System.out.print(arrays[i] + &quot;]&quot;);            &#125;else &#123;                System.out.print(arrays[i] + &quot;, &quot;);            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序：</p><ul><li>比较数组中，两个相邻的元素，如果第一个数比第二个数大，我们就交换他们的位置。</li><li>每一次比较，都会产生出一个最大和一个最小的数。</li><li>下一轮则可以少一次排序</li><li>依次循环，直到结束。</li><li>我们看到嵌套循环，想到这个算法的时间复杂度为O(n2)。</li></ul><p>冒泡排序数字替换逻辑：</p><ol><li><p>将第一额数存放到一个临时的空间当中</p><p> <img src="/2021/07/15/java-xue-xi-bi-ji-5-shu-zu/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%95%B0%E5%AD%97%E6%8D%A2%E4%BD%8D%E9%80%BB%E8%BE%9101.png" alt="冒泡排序数字换位逻辑01"></p></li><li><p>将后一个数字放入到前一个数字空间中</p><p> <img src="/2021/07/15/java-xue-xi-bi-ji-5-shu-zu/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%95%B0%E5%AD%97%E6%8D%A2%E4%BD%8D%E9%80%BB%E8%BE%9102.png" alt="冒泡排序数字换位逻辑02"></p></li><li><p>将存放在临时空间中的前一个数字放入到原本后一个数字的空间中</p><p> <img src="/2021/07/15/java-xue-xi-bi-ji-5-shu-zu/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%95%B0%E5%AD%97%E6%8D%A2%E4%BD%8D%E9%80%BB%E8%BE%9103.png" alt="冒泡排序数字换位逻辑03"></p></li></ol><p>实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;public class Demo02 &#123;    public static void main(String[] args) &#123;        int[] arrays &#x3D; &#123;1, 23, 454, 342, 55, 8848, 367, 365, 9656&#125;;        &#x2F;&#x2F;冒泡排序前        System.out.println(Arrays.toString(arrays));        &#x2F;&#x2F;进行冒泡排序        sort(arrays);        System.out.println(Arrays.toString(arrays));    &#125;    &#x2F;**     * 冒泡排序     *     * @param arrays     * @return     *&#x2F;    public static int[] sort(int[] arrays) &#123;        &#x2F;&#x2F;临时变量        int num &#x3D; 0;        &#x2F;&#x2F;外层循环：判断我们要走多少次        for (int i &#x3D; 0; i &lt; arrays.length - 1; i++) &#123;            &#x2F;&#x2F;通过flag标识来减少没有意义的比较            boolean flag &#x3D; false;            &#x2F;&#x2F;内层循环：比较判断两个数            &#x2F;&#x2F;如果第一个数比第二个数大，我们就交换他们的位置。            &#x2F;&#x2F;注意：这里的j &lt; arrays.length - 1 之后还需要减去&quot;i&quot;            for (int j &#x3D; 0; j &lt; arrays.length - 1 - i; j++) &#123;                &#x2F;&#x2F;当后一个数比前一个数大                if (arrays[j + 1] &gt; arrays[j]) &#123;                    num &#x3D; arrays[j];                    arrays[j] &#x3D; arrays[j + 1];                    arrays[j + 1] &#x3D; num;                    flag &#x3D; true;                &#125;            &#125;            if (flag &#x3D;&#x3D; false) &#123;                break;            &#125;        &#125;        return arrays;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p><strong>需求：</strong>编写五子棋游戏，有存盘退出和继续上盘的功能</p><p><strong>分析问题：</strong>因为该二维数组的很多值默认是0，因此记录了很多没有意义的数据</p><p><strong>解决方案：</strong>稀疏数组</p><p>稀疏数组介绍</p><ul><li>当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组</li><li>稀疏数组的处理方式时：<ul><li>记录数组一共有几行几列，有多少个不同值</li><li>把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模</li></ul></li><li>如下图：左边是原始数组，右边是稀疏数组</li></ul><p><img src="/2021/07/15/java-xue-xi-bi-ji-5-shu-zu/%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84%E5%92%8C%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84.png" alt="原始数组和稀疏数组"></p><p>实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo02 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;1：创建一个二维数组 11 * 11        &#x2F;&#x2F;0：默认为没有棋子； 1：黑棋， 2：白棋        int[][] array01 &#x3D; new int[11][11];        array01[1][1] &#x3D; 1;        array01[1][2] &#x3D; 2;        array01[4][6] &#x3D; 2;        array01[8][6] &#x3D; 1;        &#x2F;&#x2F;输出原始的数组        System.out.println(&quot;输出原始的数组：&quot;);        for (int[] ints: array01) &#123;            for (int anInt : ints)&#123;                System.out.print(anInt + &quot;\t&quot;);            &#125;            System.out.println();        &#125;        &#x2F;&#x2F;转换为稀疏数组来存储        &#x2F;&#x2F;获取有效值的个数        int sum &#x3D; 0;        for (int i &#x3D; 0; i &lt; array01.length; i++) &#123;            for (int j &#x3D; 0; j &lt; array01.length; j++)&#123;                &#x2F;&#x2F;计算并且获取有效值的个数                if (array01[i][j] !&#x3D; 0)&#123;                    sum++;                &#125;            &#125;                    &#125;        System.out.println(&quot;有效值的个数为：&quot; + sum);        &#x2F;&#x2F;创建一个稀疏数组        &#x2F;&#x2F;因为存在头部信息，所以稀疏数组的行为有效值个数+1，列固定为3列        int[][] array02 &#x3D; new int[sum + 1][3];        &#x2F;&#x2F;设定行和列的属性值（头部信息）        array02[0][0] &#x3D; 11;        array02[0][1] &#x3D; 11;        array02[0][2] &#x3D; sum;        &#x2F;&#x2F;遍历二维数组，将非0的值存放入稀疏数组中        int count &#x3D; 0;        for (int i &#x3D; 0; i &lt; array01.length; i++)&#123;            for (int j &#x3D; 0; j &lt; array01.length; j++)&#123;                if (array01[i][j] !&#x3D; 0)&#123;                    count++;                    array02[count][0] &#x3D; i;                    array02[count][1] &#x3D; j;                    array02[count][2] &#x3D; array01[i][j];                &#125;            &#125;        &#125;        &#x2F;&#x2F;输出稀疏数组        System.out.println(&quot;稀疏数组&quot;);        for (int i &#x3D; 0; i &lt; array02.length; i++) &#123;            System.out.println(array02[i][0] + &quot;\t&quot; + array02[i][1] + &quot;\t&quot; + array02[i][2] + &quot;\t&quot;);        &#125;        System.out.println();        &#x2F;&#x2F;还原该稀疏数组        System.out.println(&quot;还原稀疏数组&quot;);        &#x2F;&#x2F;读取稀疏数组        int[][] array03 &#x3D; new int[array02[0][0]][array02[0][1]];        &#x2F;&#x2F;给其中的元素还原值        &#x2F;&#x2F;这里第0行为稀疏数组的头部信息，不需要还原        for (int i &#x3D; 1; i &lt; array02.length; i++) &#123;            &#x2F;&#x2F;array03[i][j]的值为 i &#x3D; 行 和 j &#x3D; 列            array03[array02[i][0]][array02[i][1]] &#x3D; array02[i][2];        &#125;        &#x2F;&#x2F;打印还原后数组        System.out.println(&quot;输出原始的数组：&quot;);        for (int[] ints: array03) &#123;            for (int anInt : ints)&#123;                System.out.print(anInt + &quot;\t&quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>之后就是java中最重要的面向对象编程。加油！去吧，继续服务。 ( ﾟ ▽ ﾟ)つ□乾杯～</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>B站：<a href="https://www.bilibili.com/video/BV12J41137hu?p=30&share_source=copy_web">狂神说java</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学笔记 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将hexo博客部署到腾讯云以及用Nginx来部署ssl证书</title>
      <link href="/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/"/>
      <url>/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/</url>
      
        <content type="html"><![CDATA[<p>我们之前已经成功建立好了hexo博客并且将博客部署到GitHub上面。但是如果想要自己的博客更加正规一些，就还是需要运用到国内的云服务器平台。下面我就来给大家介绍一下如何将自己的博客部署到腾讯云的服务器上。</p><p><strong>注意：在部署在腾讯云之前，先要确保你所注册的博客的域名是已经审核通过的。</strong></p><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><p>B站：<a href="https://www.bilibili.com/video/BV1cp4y1i7C7?p=4&share_source=copy_web">教你如何用腾讯云服务器＋hexo 搭建属于自己的博客</a></p><p>Blog：<a href="https://fuchenchenle.cn/">fuchenchenle</a></p><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><ol><li><strong>本地环境</strong><ol><li>Mac操作系统</li><li><code>git</code>, <code>Node.js</code>, <code>hexo</code>…</li><li>已经拥有本地的静态网站</li><li>FileZilla软件</li></ol></li><li><strong>服务器配置</strong><ol><li>腾讯云Cenots7.6服务器</li><li><code>git</code>, <code>Nginx</code>, <code>创建git用户</code></li></ol></li></ol><h2 id="腾讯云服务器配置"><a href="#腾讯云服务器配置" class="headerlink" title="腾讯云服务器配置"></a>腾讯云服务器配置</h2><h3 id="登陆腾讯云服务器"><a href="#登陆腾讯云服务器" class="headerlink" title="登陆腾讯云服务器"></a>登陆腾讯云服务器</h3><p>首先我们要先登陆进腾讯云的操作页面中。</p><p><img src="/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/%E7%99%BB%E9%99%86%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="登陆腾讯云服务器"></p><p>使用root账户登陆的时候，可以去站内信中去找当时购买服务器时所发的邮件，上面会给你root账户的初始密码。</p><p><img src="/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/%E7%99%BB%E9%99%86%E8%85%BE%E8%AE%AF%E4%BA%91%E6%93%8D%E4%BD%9C%E9%A1%B5%E9%9D%A2.png" alt="登陆腾讯云操作页面"></p><p>就这样，我们就进入到了腾讯云的操作页面上。</p><p><img src="/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%93%8D%E4%BD%9C%E9%A1%B5%E9%9D%A2.png" alt="腾讯云操作页面"></p><h3 id="云服务器配置Git"><a href="#云服务器配置Git" class="headerlink" title="云服务器配置Git"></a>云服务器配置Git</h3><ol><li>安装依赖库</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>安装编译工具</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install gcc perl-ExtUtils-MakeMaker package<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>使用<code>git --version</code>来查看当前服务器的git版本</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我这边已经是安装了最新的git版本的，正常来说，服务器初始的git版本为1.8。</p><p><img src="/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/git%E7%9A%84%E7%89%88%E6%9C%AC.png" alt="git的版本"></p><ol start="4"><li>删除当前git</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum remove git -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>下载最新的git版本</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#下载的目录cd &#x2F;usr&#x2F;local&#x2F;src#去git官网上查看最新的git版本(我这里是2.32.0)wget https:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;software&#x2F;scm&#x2F;git&#x2F;git-2.32.0.tar.gz#解压到当前文件夹tar -zxvf git-2.32.0.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>编辑并安装git</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#进入到git文件夹(记得git的版本不要输错)cd git-2.32.0#编译源码(编译的时间有点长耐心等待)make prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git all#安装路径make prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li>配置git的环境变量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &#39;export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;git&#x2F;bin&#39; &gt;&gt; &#x2F;etc&#x2F;bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="8"><li>刷新环境变量</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source &#x2F;etc&#x2F;bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="9"><li>再次查看版本号</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="10"><li>创建git用户并且修改权限</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#输入自己的用户名adduser yourName#这边的密码是初始密码##后面可以修改建议写自己的用户名方便记忆passed yourName#修改权限chmod 740 &#x2F;etc&#x2F;sudoers#进入到文件进行修改vim &#x2F;etc&#x2F;sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入到文件之后，我们会看到这些代码</p><p><img src="/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90.png" alt="修改权限"></p><p>在此，我们只需要在root后面添加我们自己的用户就可以了。</p><p><strong>操作步骤为：</strong></p><ol><li>首先先切换成<strong>英文</strong>输入法</li><li>同时按住<code>shift</code>键和<code>:</code>键(<code>shift + :</code>)来进入命令输入行</li><li>先输入<code>set nu</code>来让代码显示行数</li><li>然后在找到root哪一行下</li><li>填入自己的用户名<code>shadowprism     ALL=(ALL)       ALL</code></li><li>然后在先按<code>esc</code>退出输入，再输入<code>wq!</code>来保存我们的修改</li></ol><h2 id="在本地创建密钥"><a href="#在本地创建密钥" class="headerlink" title="在本地创建密钥"></a>在本地创建密钥</h2><p><strong>注意：</strong></p><ul><li>使用windows系统的小伙伴需要用<strong>Gitbash</strong>来操作</li><li>使用MacOS的小伙伴就直接使用<strong>终端</strong>来操作</li></ul><h3 id="本地创建密钥"><a href="#本地创建密钥" class="headerlink" title="本地创建密钥"></a>本地创建密钥</h3><ol><li>首先我们先查看自己是否拥有密钥</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls -al ~&#x2F;.ssh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>如果输出的是<code>No such file or directory</code>，证明我们电脑没有安装密钥</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#生成新的ssh密钥##在这里的you_email填写你的GitHub的注册邮箱##之后就是全按回车确认就行###提示的要你填写密码可以填写，但是一定要记住！ssh-keygen -t rsa -C&quot;you_email&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>生成并且添加ssh密钥</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-add ~&#x2F;.ssh&#x2F;id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>查看你的ssh密钥</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#这里我们需要使用的是我们的密钥cat ~&#x2F;.ssh&#x2F;id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当我们输入完上面的代码后，终端就会出现我们的密钥。</p><p>使用windows系统的同学，直接在系统根目录去寻找<code>.ssh</code>文件夹就好。</p><ol start="5"><li>将本地创建的密钥<code>id_rsa</code>进行复制到腾讯云服务器上</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#这个操作是在腾讯云上su yourName#创建一个存储你密钥的目录mkdir ~&#x2F;.ssh#对该文件进行编辑##在该文件中，直接复制你之前得到的密钥vim ~&#x2F;.ssh&#x2F;authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>进行本地测试</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh -v fuchen@服务器ip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试通过的话，就会发现你在本地也可以联入到腾讯云。</p><h2 id="云服务器网站配置"><a href="#云服务器网站配置" class="headerlink" title="云服务器网站配置"></a>云服务器网站配置</h2><ol><li>创建网站目录并且设置权限</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#进入到root用户su root#创建网站目录mkdir &#x2F;home&#x2F;hexo#设置权限##将yourName替换成自己的用户名chown yourName:yourName -R &#x2F;home&#x2F;hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>安装<code>Nginx</code></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#下载Nginxyum install -y nginx#启动服务器##如果没有报错就证明配置成功systemctl start nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>修改Nginx配置文件</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#修改Nginx配置文件vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们需要修改<code>server_name</code>和<code>root</code>两处</p><p><img src="/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/%E4%BF%AE%E6%94%B9Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="修改Nginx配置文件"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">57     server &#123;58 #       listen       443 ssl;59 #       listen       [::]:443 ssl http2;60         server_name  shadowprism.cn; #这里填写你的域名61         root         &#x2F;home&#x2F;hexo&#x2F;; #网站目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在<code>wq!</code>保存并且退出编辑。</p><p><strong>注意：在这里填写的域名一定要是在腾讯云里进行解析过的域名。</strong></p><p><img src="/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt="DNS域名解析"></p><ol start="4"><li>重启服务器</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>建立git仓库</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#切换为root用户su root#定位到你的用户目录下cd &#x2F;home&#x2F;yournName#将git部署到该目录下git init --bare blog.git#设置权限chown yourName:yourName -R blog.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>同步网站根目录</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#修改改目录下的文件vim blog.git&#x2F;hooks&#x2F;post-receive#将下面这2行代码复制到该文件中##将yourName替换为你的用户名#!&#x2F;bin&#x2F;shgit --work-tree&#x3D;&#x2F;home&#x2F;hexo --git-dir&#x3D;&#x2F;home&#x2F;yourName&#x2F;blog.git checkout -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li>修改权限</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">##将yourName替换为你的用户名chmod +x &#x2F;home&#x2F;yourName&#x2F;blog.git&#x2F;hooks&#x2F;post-receive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="8"><li>在本地hexo目录修改_config.yml文件</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:  type: git  repo: yourName@你的IP地址:&#x2F;home&#x2F;yourName&#x2F;blog.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在本地终端部署"><a href="#在本地终端部署" class="headerlink" title="在本地终端部署"></a>在本地终端部署</h2><p>终于到了最后一步，最后我们只需要向部署到GitHub上一样使用命令行即可完成。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo cl &amp;&amp; hexo g &amp;&amp; hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h2><p>详见参考教程：</p><p>B站：<a href="https://www.bilibili.com/video/BV1cp4y1i7C7?p=4&share_source=copy_web">教你如何用腾讯云服务器＋hexo 搭建属于自己的博客</a></p><p>Blog：<a href="https://fuchenchenle.cn/">fuchenchenle</a></p><h2 id="安装SSL证书"><a href="#安装SSL证书" class="headerlink" title="安装SSL证书"></a>安装SSL证书</h2><ol><li>进入腾讯云操作页面，安装<code>vsftpd</code></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y vsftpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.修改配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf#禁止匿名用户登录anonymous_enable&#x3D;No<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/%E4%BF%AE%E6%94%B9anonymous.png" alt="修改anonymous"></p><ol start="3"><li>随后我们就要去下载FileZilla软件来进行部署操作</li></ol><h2 id="部署SSL证书"><a href="#部署SSL证书" class="headerlink" title="部署SSL证书"></a>部署SSL证书</h2><ol><li>打开FileZilla</li></ol><p>首先，我们先要用FileZilla连接到腾讯云服务器。</p><p><img src="/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/FileZilla%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="FileZilla连接服务器"></p><p><strong>注意：</strong></p><ul><li>主机是你的服务器域名</li><li>用户名和密码就是你的腾讯云用户名和密码。</li><li>端口使用22</li></ul><p>当在FileZilla右边显示出如下文件目录时候，证明我们已经连接成功。</p><p><img src="/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/FileZilla%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.png" alt="FileZilla连接成功"></p><h3 id="传输SSL证书"><a href="#传输SSL证书" class="headerlink" title="传输SSL证书"></a>传输SSL证书</h3><p>这里我提前下载好了我的SSL证书。如果你没有的话，就得先去腾讯云下载证书。下载完成以后就会有一个<code>.zip</code>的压缩文件，那个就是我们的SSL证书。</p><ol><li>将SSL证书放到我们的博客目录下</li><li>在FileZilla找到证书，双击该证书压缩包就可以上传到腾讯云服务器上。</li></ol><p><strong>我们接着部署</strong></p><ol start="2"><li>我们上传的SSL文件默认上传至我们的用户文件夹下</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;home&#x2F;yourName#查看文件ls<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>解压缩文件</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unzip ~.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压完成后，会在我们的文件夹下生成 <code>Nginx</code> <code>Apache</code> <code>IIS</code> <code>Tomcat</code> 文件夹 我们只需要用Nginx</p><ol start="4"><li>将Nginx文件夹下的文件复制到新建的文件夹下</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#先创建ssl文件夹mkdir &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;#进入到Nginx文件夹中##我们用ls发现会有2个文件cd &#x2F;home&#x2F;fuchen&#x2F;Nginx#复制2个文件到&#39;&#x2F;etc&#x2F;nginx&#x2F;ssl&#39;目录下cp 文件名.crt &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;cp 文件名.key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.打开nginx.conf 文件夹 修改配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时我们还需要对文件进行修改：</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">server &#123;    listen 443 ssl;    ssl on;    server_name  你的域名.cn;    #域名    root         &#x2F;home&#x2F;hexo;        #网站主目录    ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;1_shadowprism.cn_bundle.crt; #crt文件路径    ssl_certificate_key &#x2F;etc&#x2F;ssl&#x2F;2_shadowprism.cn.key; #key文件路径    ssl_session_cache shared:SSL:1m;    ssl_session_timeout  10m;    ssl_ciphers HIGH:!aNULL:!MD5;    ssl_prefer_server_ciphers on;         #默认请求    location &#x2F; &#123;        root &#x2F;home&#x2F;hexo;        #定义首页索引文件名称        index index.html;    &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改的内容：</p><p><img src="/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/%E4%BF%AE%E6%94%B9nginx%E6%96%87%E4%BB%B6.png" alt="修改nginx文件"></p><ol start="6"><li>查看是否有报错，无报错重启服务器</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -t#如果没有报错的话，就重启服务器systemctl restart nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上我们就可以看到我们的博客的开头就是<code>https:</code>开头了。</p><p>好耶～</p><p><img src="/2021/07/14/jiang-hexo-bo-ke-bu-shu-dao-teng-xun-yun/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A4%B4.png" alt="https开头"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在经过了几次曲折以后，还是终于完成了对自己博客的配置。但是我也必须明白，即使是在精美的博客页面，没有内容也还是没有作用的。所以，我也会在以后继续更新博客。分享知识、结交朋友，感谢你的观看！ ( ﾟ ▽ ﾟ)つ□乾杯～</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
            <tag> Cenots </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记4-java方法</title>
      <link href="/2021/07/13/java-xue-xi-bi-ji-4-java-fang-fa/"/>
      <url>/2021/07/13/java-xue-xi-bi-ji-4-java-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>自用的学习笔记，若有错误欢迎指出。</p><h2 id="java方法"><a href="#java方法" class="headerlink" title="java方法"></a>java方法</h2><ul><li>java方法是语句的集合，它们在一起执行一个功能。<ul><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或者对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul></li><li>设计方法的原则：方法本意是功能块，就是实现某个功能的语句块集合。我们设计方法的时候，最好保持方法的原子性。<strong>就是一个方法只能完成一个功能，这样利于我们后期的扩展。</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo01 &#123;    &#x2F;&#x2F;main方法    public static void main(String[] args) &#123;        &#x2F;&#x2F;实际参数：实际上传递给方法的参数        int sum &#x3D; add(88, 48);        System.out.println(sum);    &#125;    &#x2F;&#x2F;参数a &amp; b 为形式参数    public static int add(int a, int b)&#123;        return a + b;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><p>java的方法类似于其他语言的函数，是一<strong>段用来完成特定功能的代码片段</strong>。一般情况下，定义一个方法包含一下语法：</p><ul><li><strong>方法包含一个方法头和一个方法体</strong>。下面是一个方法的所有部分：<ul><li><strong>修饰符</strong>：修饰符，这是可选的，目的是告诉编辑器如何调用该方法。定义了该方法的访问类型。</li><li><strong>返回值类型</strong>：方法可能会返回值。<code>returnValueType</code> 是方法返回值的数据类型。有些方法执行所需的操作，但是没有返回值。在这种情况下，<code>returnValueType</code>是关键字void。</li><li><strong>方法名</strong>：是方法的实际名称。方法名和修饰符共同构成方法签名。</li><li><strong>参数类型</strong>：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或者变量。参数列表时指方法的参数类型、顺序和参数的个数。参数时可选的，方法可以不包含任何参数。<ul><li>形式参数：在方法被调用时用于接收外界输入的数据。</li><li>实参：调用方法时实际传给方法的数据。</li></ul></li><li><strong>方法体</strong>：方法体包含具体的语句，定义该方法的功能。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">修饰符 返回值类型 方法名(参数类型 参数名)&#123;  &#x2F;&#x2F;方法体  return 返回值;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实例：比大小</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;    double max &#x3D; max(79, 81);    System.out.println(max);&#125;public static double max(double a, double b)&#123;    double result &#x3D; 0;    if (a &#x3D;&#x3D; b)&#123;        System.out.println(&quot;两个值相等&quot;);        return 0; &#x2F;&#x2F;终止方法    &#125;    if (a &lt; b)&#123;        result &#x3D; b;    &#125;else &#123;        result &#x3D; a;    &#125;    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>重载就是在一个类中，有相同的函数名称，但是形参不同的函数。</p><p>方法的重载的规则：</p><ul><li><strong>方法名称必须相同</strong></li><li><strong>参数列表必须不同(个数不同、或类型不同、参数排列顺序不同等)</strong></li><li><strong>方法的返回类型可以相同也可以不同</strong></li><li><strong>仅仅返回类型不同不足以成为方法的重载</strong></li></ul><p>实现理论：</p><ul><li>方法名称相同是，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，选择以对应的方法，如果匹配失败，则编译器报错。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int max(int a, int b)&#123;...&#125;&#x2F;&#x2F;重载public static int max(int a, int b, int c)&#123;...&#125;public static double max(double a, double b)&#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h2><p>有时候你希望运行一个程序时候再传递给它消息。这要靠传递命令行参数给main()函数实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CommandLine&#123;    public static void main(String arg[])&#123;        &#x2F;&#x2F;args.length 数组长度        for(int i &#x3D; 0; i &lt; args.length; i++)&#123;            System.out.println(&quot;args[&quot; + i + &quot;]:&quot; + args[i]);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><ul><li>JDK1.5开始，java支持传递同类型的可变参数给一个方法。</li><li>载方法声明中，载指定参数类型后加一个省略号(…)</li><li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</li></ul><p>实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo02 &#123;    public static void main(String[] args) &#123;        Demo02 demo02 &#x3D; new Demo02();        demo02.test(1, 3, 5, 7, 9, 11, 13, 15, 17);    &#125;    public void test(int p, int... i)&#123;        System.out.println(i[7]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例2:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo02 &#123;    public static void main(String[] args) &#123;        printMax(1, 2, 3, 56, 7, 5);        printMax(new double[]&#123;1, 2, 3, 4, 5, 6&#125;);    &#125;    public static void printMax(double... number)&#123;        if (number.length &#x3D;&#x3D; 0)&#123;            System.out.println(&quot;请输入数字！&quot;);            return;        &#125;        double result &#x3D; number[0];        &#x2F;&#x2F;排序        for (int i &#x3D; 1; i &lt; number.length; i++)&#123;            if (number[i] &gt; result)&#123;                result &#x3D; number[i];            &#125;        &#125;        System.out.println(&quot;最大的数字为：&quot; + result);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归就是：A方法调用B方法，自己调用自己</p><p>利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个个与原问题相似的、规模较小的问题来求解。递归的策略就是只需要少量的程序就可以描述出解题过程中的多次重复计算，大大减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</p><p><strong>递归结构包括两个部分：</strong></p><ul><li><strong>递归头：什么时候不掉用自身方法。如果没有递归头，程序就会进入死循环。</strong></li><li><strong>递归体：什么时候需要调用自身方法。</strong></li></ul><p>实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;使用递归来计算阶乘public class Demo03 &#123;    public static void main(String[] args) &#123;        System.out.println(f(8));    &#125;    public static int f(int i)&#123;        if (i &#x3D;&#x3D; 0)&#123;            return 1;        &#125;else &#123;            return i * f(i - 1);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：当调用的数字过大的时候，就会严重影响机器的性能，同时输出结果会溢出。</strong></p><hr><p><strong>制作一个简单的计算器：</strong></p><ul><li>支持4位运算符：+，—，*，/</li><li>使用循环和switch循环来判定用户的交互</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.math.BigDecimal;import java.util.Scanner;public class Demo03 &#123;    public static void main(String[] args) &#123;        Scanner scanner01 &#x3D; new Scanner(System.in);        while (true) &#123;            System.out.println(&quot;请输入第一个数字A：&quot;);            double inputNumber01 &#x3D; scanner01.nextDouble();            System.out.println(&quot;请输入运算符号：&quot;);            String inputOperator &#x3D; scanner01.next();            System.out.println(&quot;请输入第二个数字B：&quot;);            double inputNumber02 &#x3D; scanner01.nextDouble();            switch (inputOperator) &#123;                case &quot;+&quot;:                    System.out.println(&quot;A&quot; + inputOperator + &quot;B的结果为：&quot; + add(inputNumber01, inputNumber02));                    continue;                case &quot;-&quot;:                    System.out.println(&quot;A&quot; + inputOperator + &quot;B的结果为：&quot; + subtract(inputNumber01, inputNumber02));                case &quot;*&quot;:                    System.out.println(&quot;A&quot; + inputOperator + &quot;B的结果为：&quot; + multiply(inputNumber01, inputNumber02));                case &quot;&#x2F;&quot;:                    System.out.println(&quot;A&quot; + inputOperator + &quot;B的结果为：&quot; + divide(inputNumber01, inputNumber02));                default:                    System.out.println(&quot;无效的运输符号&quot;);            &#125;        &#125;    &#125;    public static double add(double inputNumber01, double inputNumber02)&#123;        double sum &#x3D; inputNumber01 + inputNumber02;        return sum;    &#125;    public static double subtract(double inputNumber01, double inputNumber02)&#123;        double sum &#x3D; inputNumber01 - inputNumber02;        return sum;    &#125;    public static double multiply(double inputNumber01, double inputNumber02)&#123;        double sum &#x3D; inputNumber01 * inputNumber02;        return sum;    &#125;    public static double divide(double inputNumber01, double inputNumber02)&#123;        BigDecimal a1 &#x3D; new BigDecimal(inputNumber01);        BigDecimal b1 &#x3D; new BigDecimal(inputNumber02);        return a1.divide(b1).doubleValue();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>B站：<a href="https://www.bilibili.com/video/BV12J41137hu?p=30&share_source=copy_web">狂神说java</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学笔记 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记3-流程控制</title>
      <link href="/2021/07/09/java-xue-xi-bi-ji-3-liu-cheng-kong-zhi/"/>
      <url>/2021/07/09/java-xue-xi-bi-ji-3-liu-cheng-kong-zhi/</url>
      
        <content type="html"><![CDATA[<p>自用的学习笔记，若有错误欢迎指出。</p><h2 id="java包机制"><a href="#java包机制" class="headerlink" title="java包机制"></a>java包机制</h2><p>为了更好地组织类，java提供了包机制，用于区别类名的命名空间。</p><p>包语句的语法格式为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package pkg1[.pkg2[.pkg3...]];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>一般利用公司域名倒序来作为包名字。</strong>例如：<code>www.baidu.com</code>，如果要建包的话：<code>com.baidu.www</code>这样来命名。</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>当我们需要调用一些函数或者某一个包的成员的时候，我们需要在java程序中明确的导入该包。使用<code>import</code>关键字来实现包导入。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import package1[.package2...].(classname|*);import java.util.Date;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用<code>*</code>来导入这个包下面的所有类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.shadowprism.base.*;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="JavaDoc"><a href="#JavaDoc" class="headerlink" title="JavaDoc"></a>JavaDoc</h2><ul><li><code>javadoc</code>命令是用来生成自己的API文档的。</li><li>参数信息<ul><li><code>@author</code> 作者名</li><li><code>@version</code> 版本号</li><li><code>@since</code> 指明需要最早使用的JDK版本</li><li><code>@param</code> 参数名</li><li><code>@return</code> 返回值情况</li><li><code>@throws</code> 异常抛出情况</li></ul></li></ul><p>文档注释可以给类加注释的同时也可以给方法加注释。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.shadowprism.base;&#x2F;** * @author shadowprism * @version 1.0 * @since 1.8 *&#x2F;public class Doc &#123;    String name;        &#x2F;**     * @param name     * @return     * @throws Exception     *&#x2F;    public String test(String name)&#123;        return name;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用cmd在java文件目录下生成JavaDoc文档。</p><ol><li>使用<code>cd /d F:你的文件\你的文件</code>来定位到你的文件位置</li><li>在java文件目录下输入<code>javadoc -encoding UTF-8 -charset UTF-8 Doc.java</code></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#使用-encoding UTF-8 -charset UTF-8是为了防止文章出现乱码javadoc -encoding UTF-8 -charset UTF-8 Doc.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>**有待解决的问题：</p><ul><li>在cmd中输入的<code>javadoc</code>输出结果为“不是内部指令…”，但是在<code>jdk</code>的<code>bin</code>目录下却可以运行<code>javadoc -help</code>。</li></ul><h2 id="java流程控制"><a href="#java流程控制" class="headerlink" title="java流程控制"></a>java流程控制</h2><h3 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a>Scanner对象</h3><p>java提供的一个工具类，我们可以获取用户的输入。<code>java.util.Scanner</code>是Java5的新特征，我们可以通过<code>Scanner</code>类来获取用户的输入。</p><p>基本语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Scanner scan &#x3D; new Scanner(System.in);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过<code>Scanner</code>类的<code>next()</code>于<code>nextLine()</code>方法获取输入的字符串，在读取前我们一般需要使用<code>hasNext()</code>与<code>hasNextLine()</code>判断是否还有输入的数据。</p><p>实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class Demo01 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;创建一个扫描器对象来接收键盘数据        Scanner scan01 &#x3D; new Scanner(System.in);        Scanner scan02 &#x3D; new Scanner(System.in);        System.out.println(&quot;使用next方式来接收: &quot;);        &#x2F;&#x2F;判断用户有没有输入字符串        if (scan01.hasNext())&#123;            String str &#x3D; scan01.next();            System.out.println(&quot;输入的内容为：&quot; + str);        &#125;        System.out.println(&quot;使用nextLine方式来接收: &quot;);        String str &#x3D; scan02.nextLine();        System.out.println(&quot;输入的内容为：&quot; + str);                &#x2F;&#x2F;凡是属于IO流的类如果不关闭会一直暂用资源，建议用掉就关闭        scan01.close();scan02.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong>在<code>hasNext()</code>方法中，如果输入的内容为<code>hello world</code>这样带中间带空格的字符串，最终结果只会输出为<code>hello</code>。需要使用<code>hasNextLine()</code>方法。</p><ul><li><code>next():</code><ul><li>一定要读取到有效字符后才可以结束输入</li><li>对输入有效字符之前遇到的空白，<code>next()</code>方法会自动将其去掉</li><li>只有输入有效字符后才将其后面的空白作为分隔符或者结束符</li><li><code>next()</code>不能得到带有空格的字符串</li></ul></li><li><code>nextLine():</code><ul><li>以回车键ENTER为结束符，也就是说<code>nextLine()</code>方法返回的是输入回车之前的所有字符</li><li>可以获得空白</li></ul></li></ul><h3 id="Scanner进阶"><a href="#Scanner进阶" class="headerlink" title="Scanner进阶"></a>Scanner进阶</h3><p>实例：我们可以输入多个数字，并且求其总和和平均数，每输入一个数字用ENTER键确认。如果输入了非数字就表示我们要结束输入，执行输出结果。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class Demo01 &#123;    public static void main(String[] args) &#123;                Scanner scanner01 &#x3D; new Scanner(System.in);        double sum &#x3D; 0; &#x2F;&#x2F;求和        double average &#x3D; 0; &#x2F;&#x2F;平均数        int inputNumTimes &#x3D; 0; &#x2F;&#x2F;计算输入多少个数字        System.out.println(&quot;请输入数字：&quot;);        while (scanner01.hasNextDouble())&#123;            double d &#x3D; scanner01.nextDouble();            inputNumTimes++;            sum &#x3D; sum + d; &#x2F;&#x2F;求和        &#125;        average &#x3D; sum &#x2F; inputNumTimes; &#x2F;&#x2F;计算平均数        System.out.println(&quot;求和结果为：&quot; + sum);        System.out.println(&quot;平均数为：&quot; + average);        scanner01.close(); &#x2F;&#x2F;结束进程    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><ul><li>java的基本结构就是顺序结构，除非特别指明，否则就按顺序一句一句执行。</li><li>顺序结构是最简单的算法结构。</li><li>语句与语句之间，框与框之间是按照从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的，它是任何一个算法都离不开的一种基本算法结构。</li></ul><h3 id="if选择结构"><a href="#if选择结构" class="headerlink" title="if选择结构"></a>if选择结构</h3><h4 id="if单选择结构"><a href="#if单选择结构" class="headerlink" title="if单选择结构"></a>if单选择结构</h4><p>我们很多时候需要去判断一个东西是否可行，然后我们才去执行，这样一个过程在程序中用<code>if</code>语句来表示。</p><p>语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(布尔表达式)&#123;    &#x2F;&#x2F;如果布尔表达式为true将执行语句&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Scanner scanner &#x3D; new Scanner(System.in);String str &#x3D; scanner.nextLine();if (str.equals(&quot;Boy&quot;))&#123;    System.out.println(str);&#125;scanner.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="if双选择结构"><a href="#if双选择结构" class="headerlink" title="if双选择结构"></a>if双选择结构</h4><p>例子：如果一个公司需要收购软件，如果成功了就需要给别人支付100w。如果失败就选择自己开发软件。这样就需要有两个判断，需要一个双选择结构，所以就有了<code>if -else</code>结构。</p><p>语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(布尔表达式)&#123;    &#x2F;&#x2F;如果布尔表达式为true&#125;else &#123;    &#x2F;&#x2F;如果布尔表达式为false&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Scanner scanner &#x3D; new Scanner(System.in);System.out.println(&quot;请输入成绩：&quot;);int i &#x3D; scanner.nextInt();if (i &gt;&#x3D; 60)&#123;    System.out.println(&quot;及格&quot;);&#125;else &#123;    System.out.println(&quot;不及格&quot;);&#125;scanner.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="if多选择结构"><a href="#if多选择结构" class="headerlink" title="if多选择结构"></a>if多选择结构</h4><p>语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(布尔表达式)&#123;    &#x2F;&#x2F;如果布尔表达式1的值为true，执行代码&#125;else if &#123;    &#x2F;&#x2F;如果布尔表达式2值为true，执行代码&#125;else if &#123;    &#x2F;&#x2F;如果布尔表达式3值为true，执行代码&#125;else &#123;    &#x2F;&#x2F;如果以上的布尔表达式都不为true,执行代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Scanner scanner &#x3D; new Scanner(System.in);System.out.println(&quot;请输入成绩：&quot;);int i &#x3D; scanner.nextInt();if (i &#x3D;&#x3D; 100)&#123;    System.out.println(&quot;满分&quot;);&#125;else if (i &gt;&#x3D; 80 &amp;&amp; 1 &lt; 100)&#123;    System.out.println(&quot;优秀&quot;);&#125;else if (i &gt;&#x3D; 70 &amp;&amp; 1 &lt; 80)&#123;    System.out.println(&quot;良&quot;);&#125;else if (i &gt;&#x3D; 60 &amp;&amp; 1 &lt; 70)&#123;    System.out.println(&quot;及格&quot;);&#125;else &#123;    System.out.println(&quot;不及格&quot;);&#125;scanner.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="if嵌套结构"><a href="#if嵌套结构" class="headerlink" title="if嵌套结构"></a>if嵌套结构</h4><p>语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(布尔表达式1)&#123;    &#x2F;&#x2F;如果布尔表达式1的值为true，执行代码   if (布尔表达式2)&#123;       &#x2F;&#x2F;如果布尔表达式2的值为true，执行代码   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="switch多选择结构"><a href="#switch多选择结构" class="headerlink" title="switch多选择结构"></a>switch多选择结构</h3><p>多选择结构还有一个实现方式就是<code>switch case</code>语句。</p><p><code>switch case</code>语句判断一个变量与一个系列值中某个值是否相等，每一个值称为一个分支。</p><p><code>switch</code>语句中的变量类型可以是：</p><ul><li><code>byte</code>、<code>short</code>、<code>int</code>、或者<code>char</code></li><li>从JavaSE7才开始<code>switch</code>支持字符串<code>String</code>类型</li><li>同时<code>case</code>标签必须为字符串常量火字面量</li></ul><p>语句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">switch(expression)&#123;    case value :        &#x2F;&#x2F;语句        break; &#x2F;&#x2F;可选    case value :        &#x2F;&#x2F;语句        break; &#x2F;&#x2F;可选    &#x2F;&#x2F;可以有任意数量的case语句    default : &#x2F;&#x2F;可选        &#x2F;&#x2F;语句&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">char grade &#x3D; &#39;A&#39;;switch (grade) &#123;    case &#39;A&#39;:        System.out.println(&quot;优秀&quot;);        break;    case &#39;B&#39;:        System.out.println(&quot;良好&quot;);        break;    case &#39;C&#39;:        System.out.println(&quot;及格&quot;);        break;    case &#39;D&#39;:        System.out.println(&quot;再接再厉&quot;);        break;    default:        System.out.println(&quot;未知等级&quot;);        break;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>*如果不使用<code>break</code>的话，程序会一直运行到最后一个判断。</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ul><li><code>while</code>循环</li><li><code>do...while</code>循环</li><li><code>for</code>循环</li></ul><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p><code>while</code>循环是最基本的循环，它的结构为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">while(布尔表达式)&#123;    &#x2F;&#x2F;循环结构&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>只要布尔表达式为<code>true</code>，循环就会一直下去。</li><li><strong>我们大多数情况下是会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环。</strong></li><li>少部分情况需要循环一直执行，比如服务器的请求响应监听等。</li></ul><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h4><ul><li>对于<code>while</code>语句而言，如果不满足条件则不能进入循环。</li><li><code>do...while</code>循环至少会执行一次循环。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">int i &#x3D; 0;int sum &#x3D; ;do&#123;    sum &#x3D; sum + i;    i++;&#125;while(i &lt;&#x3D; 100);System.out.println(sum); &#x2F;&#x2F; 5050<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h4><ul><li><p><code>for</code>循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。</p></li><li><p><code>for</code>循环执行的次数是在执行前就确定的。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">for(初始化; 布尔表达式; 更新)&#123;    &#x2F;&#x2F;代码语句&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实例1：计算1-100之间的奇数和偶数的和</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int oddSum &#x3D; 0; &#x2F;&#x2F;初始化奇数和int evenSum &#x3D; 0; &#x2F;&#x2F;初始化偶数和for (int i &#x3D; 0; i &lt; 100; i++) &#123;    if (i % 2 !&#x3D; 0)&#123;        oddSum +&#x3D; i;    &#125;else &#123;        evenSum +&#x3D; i;    &#125;&#125;System.out.println(&quot;奇数和为：&quot; + oddSum); &#x2F;&#x2F; 2500System.out.println(&quot;偶数和为：&quot; + evenSum); &#x2F;&#x2F; 2450<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例2：用<code>while</code>或者<code>for</code>循环输出1-1000之间能被5整除的数，并且每行输出3个。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for (int i &#x3D; 0; i &lt;&#x3D; 1000; i++)&#123;  if (i % 5 &#x3D;&#x3D; 0)&#123;    System.out.print(i + &quot;\t&quot;); &#x2F;&#x2F;这里的&quot;\t&quot;为转义字符  &#125;  if (i % 15 &#x3D;&#x3D; 0)&#123;    System.out.println();  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例3：打印九九乘法表</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for (int i &#x3D; 1; i &lt;&#x3D; 9; i++)&#123;  for (int j &#x3D; 1; j &lt;&#x3D; i; j++)&#123;    System.out.print(i + &quot;*&quot; + j + &quot;&#x3D;&quot; + (i * j) + &quot;\t&quot;);  &#125;  System.out.println();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="增强型for循环"><a href="#增强型for循环" class="headerlink" title="增强型for循环"></a>增强型<code>for</code>循环</h4><ul><li>在java5引入了一种主要用于或集合的增强型for循环</li><li>java增强型for循环语法格式如下：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">for (声明语句: 表达式)&#123;  &#x2F;&#x2F;代码语句&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</li><li>表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</li></ul><h4 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h4><ul><li><code>break</code>：在任何循环语句的主题部分，均可用<code>break</code>来控制循环的流程，<code>break</code>用于强行退出循环，不执行循环中剩余的语句。(<code>break</code>语句在<code>switch</code>语句中也有使用)</li><li><code>continue</code>语句用于循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</li></ul><h2 id="流程控制练习"><a href="#流程控制练习" class="headerlink" title="流程控制练习"></a>流程控制练习</h2><p>打印一个三角形</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for (int i &#x3D; 1; i &lt;&#x3D; 5; i++)&#123;  for (int j &#x3D; 5; j &gt;&#x3D; i; j--)&#123;    System.out.print(&quot;#&quot;);  &#125;  System.out.println();&#125;&#x2F;&#x2F;输出结果###############<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印一个等边三角形</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;第一步：打印等边三角形的左半边for (int i &#x3D; 1; i &lt;&#x3D; 5; i++)&#123;  for (int j &#x3D; 5; j &gt;&#x3D; i; j--)&#123;    System.out.print(&quot; &quot;);  &#125;  for (int j &#x3D; 1; j &lt;&#x3D; i; j++)&#123;    System.out.print(&quot;#&quot;);  &#125;  System.out.println();&#125;&#x2F;&#x2F;输出结果     *    **   ***  **** *****;&#x2F;&#x2F;第二步：打印等边三角形的另一边&#x2F;&#x2F;之前的不变for (int i &#x3D; 1; i &lt;&#x3D; 5; i++)&#123;  for (int j &#x3D; 5; j &gt;&#x3D; i; j--)&#123;    System.out.print(&quot; &quot;);  &#125;  for (int j &#x3D; 1; j &lt;&#x3D; i; j++)&#123;    System.out.print(&quot;*&quot;);  &#125;    &#x2F;&#x2F;在此加入：  for (int j &#x3D; 1; j &lt; i; j++)&#123;    System.out.print(&quot;*&quot;);  &#125;    System.out.println();&#125;&#x2F;&#x2F;输出结果     *    ***   *****  ******* *********;&#x2F;&#x2F;其中等边三角形的右半边打印的是**********;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>之后，我也会继续学习java，继续更新博客。分享知识、结交朋友，感谢你的观看！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>B站：<a href="https://www.bilibili.com/video/BV12J41137hu?p=30&share_source=copy_web">狂神说java</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学笔记 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记2 - java基础</title>
      <link href="/2021/07/07/java-xue-xi-bi-ji-2-java-ji-chu/"/>
      <url>/2021/07/07/java-xue-xi-bi-ji-2-java-ji-chu/</url>
      
        <content type="html"><![CDATA[<p>自用的学习笔记，若有错误欢迎指出。</p><h2 id="java关键字"><a href="#java关键字" class="headerlink" title="java关键字"></a>java关键字</h2><p>java所有的组成部分都需要名字。类名、变量名以及方法名都被称之为标识符。</p><p>以下的这些都是java的关键字，在命名的时候<strong>不能使用</strong>。</p><p><img src="/2021/07/07/java-xue-xi-bi-ji-2-java-ji-chu/java%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="java关键字"></p><h2 id="java命名注意点"><a href="#java命名注意点" class="headerlink" title="java命名注意点"></a>java命名注意点</h2><ul><li>所有的标识符都应该以字母(A-Z, a - z)、美元符$、或者下划线<code>_</code>开始。</li><li>首字符之后可以是字母(A-Z, a - z)、美元符$、或者下划线<code>_</code>的任意字符组合。</li><li><strong>不能使用关键字作为变量名或者方法名。</strong></li><li>标识符是<strong>大小写敏感</strong>的。</li></ul><h3 id="变量命名规范-important"><a href="#变量命名规范-important" class="headerlink" title="变量命名规范[important]"></a>变量命名规范[important]</h3><ul><li><p>所有的变量、方法、类名要做到：简洁明了</p></li><li><p>类成员变量：首字母小写和驼峰原则</p></li><li><p>局部变量：首字母小写和驼峰原则</p></li><li><p>常量：大写字母和下划线：MAX_VALUE</p></li><li><p>类名：首字母大写和驼峰原则</p></li><li><p>方法名：首字母小写和驼峰原则</p></li><li><p>合法标识符举例：</p><ul><li>age</li><li>$salary</li><li>_value</li><li>_1boy</li></ul></li><li><p>非法标识符举例：</p><ul><li>123abc</li><li>207somker</li><li>-salary</li><li>#boy</li></ul></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><p>java是一门强类型语言</p><ul><li>要求变量的使用严格规定，所有的变量都必须先定义后使用。</li></ul></li><li><p>java的数据类型分为两大类</p><ul><li>基本类型(primitive type)<ul><li>数值类型<ul><li>整数类型<ul><li>byte: 占1个字节范围：-128~127</li><li>short：占2个字节范围：-32768~32767</li><li>int：占4个字节范围：-2147483648~2147483647</li><li>long：占8个字节范围：略</li></ul></li><li>浮点类型<ul><li>float：占4个字节</li><li>double：占8个字节</li></ul></li><li>字符类型(char占8个字节)</li></ul></li><li>Boolean类型(占1位其值只有true &amp; false)</li></ul></li><li>引用类型(reference type)<ul><li>类</li><li>接口</li><li>数组</li></ul></li></ul></li></ul><hr><h3 id="整数类型于浮点类型"><a href="#整数类型于浮点类型" class="headerlink" title="整数类型于浮点类型"></a>整数类型于浮点类型</h3><ul><li><strong>进制</strong>：<ul><li>二进制：0b</li><li>十进制</li><li>八进制：0</li><li>十六进制：0x</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** 整数类型扩展*&#x2F;int i &#x3D; 10;int i2 &#x3D; 010; &#x2F;&#x2F;八进制int i3 &#x3D; 0x10; &#x2F;&#x2F;十六进制&#x2F;&#x2F;输出结果为System.out.print(i); &#x2F;&#x2F; 10System.out.print(i2); &#x2F;&#x2F; 8System.out.print(i3); &#x2F;&#x2F; 16&#x2F;** 浮点类型扩展*&#x2F;float f &#x3D; 0.1f;double d &#x3D; 1.0 &#x2F; 10;System.out.print(f &#x3D;&#x3D; d); &#x2F;&#x2F; false&#x2F;&#x2F;浮点数精度溢出&#x2F;&#x2F;使用 BigDecimal 数学工具类来表示银行的业务。float f1 &#x3D; 21313131313131313f;float f2 &#x3D; f1 + 1;System.out.print(f1 &#x3D;&#x3D; f2); &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="字符类型扩展"><a href="#字符类型扩展" class="headerlink" title="字符类型扩展"></a>字符类型扩展</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** 字符类型扩展*&#x2F;char c1 &#x3D; &#39;a&#39;;char c2 &#x3D; &#39;M&#39;;char c3 &#x3D; &#39;中&#39;;System.out.println(c1); &#x2F;&#x2F; aSystem.out.println((int)c2);&#x2F;&#x2F; 77System.out.println((int)c3);&#x2F;&#x2F; 20013&#x2F;** char类型会涉及到Unicode编码: U0000 - UFFFF* 2的16次方 2^16 &#x3D; 65536*&#x2F;char c4 &#x3D; &#39;\u0079&#39;;System.out.println(c1); &#x2F;&#x2F; y&#x2F;* 转义字符 \t : 制表符 \n : 换行 详见：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;yaochc&#x2F;p&#x2F;4574910.html*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>由于Java是强类型语言，所以当需要进行某些运算的时候，需要用到类型转换。</p><p>运算中，不同类型的数据优先转化为同一类型，然后进行运算。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;低 -------------------------------------------&gt; 高byte, short, char -&gt; int -&gt; long -&gt; float -&gt; double<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意点：</strong></p><ol><li>不能对布尔值进行转换</li><li>不能把对象类型转换为不相干的类型</li><li>在把高容量转换为低容量的时候，需要强制转换</li><li>在转换的时候，可能出现内存溢出或者精度问题的出现</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;强制转换 (类型)变量名 高-&gt;低int i &#x3D; 128;byte b &#x3D; (int)i;System.out.println(i);System.out.println(b); &#x2F;&#x2F;内存溢出&#x2F;&#x2F;自动转换 低-&gt;高int num1 &#x3D; 128;double num2 &#x3D; num1;System.out.println(num2); &#x2F;&#x2F;128.0&#x2F;&#x2F;强制转换造成的精度缺失System.out.println((int)25.6); &#x2F;&#x2F;25System.out.println((int)-68.88); &#x2F;&#x2F;-68&#x2F;&#x2F;操作比较大的数的时候，要注意溢出问题&#x2F;&#x2F;JDK7的新特性，数字直接可以用&quot;_&quot;下划线分割int money &#x3D; 1_000_000_000;int year &#x3D; 30;int total &#x3D; money * year;long total2 &#x3D; money * year; &#x2F;&#x2F;由于默认是int类型，所以在数字转换以前就存在问题long total3 &#x3D; ((long)money) * year; &#x2F;&#x2F;先把一个System.out.println(total); &#x2F;&#x2F;内存溢出System.out.println(total2); &#x2F;&#x2F;内存溢出System.out.println(total3); &#x2F;&#x2F;输出结果正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="什么是字节"><a href="#什么是字节" class="headerlink" title="什么是字节"></a>什么是字节</h2><ul><li>位(bit)：是计算机内部数据最小单位。例：1100 1100是一个八位二进制数。</li><li>字节(byte)：是计算机中数据处理的基本单位，习惯上用大写B来表示。</li><li>1B(byte，字节) = 8bit(位)</li><li>字符：是指计算机中使用的字母、数字、字和符号。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量就是可以变化的量。</p><p>java一种强类型语言，每个变量都必须先声明其类型。</p><p>java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;数据类型 变量名 &#x3D; 值; 可以使用逗号来隔开声明多个同类型变量type varName [&#x3D;value] [&#123;,varName[&#x3D;value]&#125;];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>注意事项：</strong><ul><li>每个变量都有类型，类型可以是基本类型，也可以是引用类型。</li><li>变量名必须是合法的标识符。</li><li>变量声明是一条完整的语句，因此每一个声明都必须以分号<code>;</code>结束。</li></ul></li></ul><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul><li>类变量</li><li>实例变量</li><li>局部变量</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Variable &#123;    static int allClicks &#x3D; 0; &#x2F;&#x2F;类变量    String str &#x3D; &quot;HelloWorld!&quot;; &#x2F;&#x2F;实例变量        public void method()&#123;        int i &#x3D; 0; &#x2F;&#x2F;局部变量    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例变量：从属于对象，如果不初始化，其初始值为0<br>布尔值的默认值为：false<br>除了基本类型，其余的默认值为null</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo1&#123;    &#x2F;&#x2F;属性：变量        &#x2F;&#x2F;类变量    static double salary &#x3D; 2500;        &#x2F;&#x2F;实例变量：从属于对象，如果不初始化，其初始值为0    &#x2F;&#x2F;布尔值的默认值为：false    &#x2F;&#x2F;除了基本类型，其余的默认值为null    String name;    int age;        public static void main(String[] args)&#123;        &#x2F;&#x2F;局部变量：必须声明和初始化值        int i &#x3D; 10;        System.out.println(i); &#x2F;&#x2F;输出结果：10                &#x2F;&#x2F;变量类型 变量名字 &#x3D; new Demo1();        Demo1 demo1 &#x3D; new Demo1();        System.out.println(demo1.age); &#x2F;&#x2F;输出结果：0        System.out.println(demo1.name); &#x2F;&#x2F;输出结果：null                &#x2F;&#x2F;类变量 static        System.out.println(salary); &#x2F;&#x2F;输出结果：2500.0    &#125;        &#x2F;&#x2F;其他方法    public void add()&#123;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>常量</strong>(Constant): 初始化(initialize)后不能再改变值，是不会变动的值。</p><p>所谓常量可以理解成一种特殊的变量，它的值被设定之后，在程序运行的过程中不允许被改变。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;final 常量名 &#x3D; 值;final double PI &#x3D; 3.14;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>常量名一般使用大写字符。</strong></p><h2 id="java运算符"><a href="#java运算符" class="headerlink" title="java运算符"></a>java运算符</h2><p><a href="https://www.runoob.com/java/java-operators.html?_t_t_t=0.3133259497117251">点这里到: 菜鸟教程-java运算符</a></p><p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：</p><ul><li>算术运算符</li><li>关系运算符</li><li>位运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;二元运算符long a &#x3D; 123123123123L;int b &#x3D; 123;short c &#x3D; 10;byte d &#x3D; 6;double e &#x3D; 2.0;        System.out.println(a + b + c + d); &#x2F;&#x2F;输出的值为longSystem.out.println(b + c + d); &#x2F;&#x2F;输出的值为intSystem.out.println(c + d); &#x2F;&#x2F;输出的值为intSystem.out.println(a &#x2F; b); &#x2F;&#x2F;输出的值为longSystem.out.println(c &#x2F; e); &#x2F;&#x2F;输出的值为double<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="自增自减：-、"><a href="#自增自减：-、" class="headerlink" title="自增自减：++ 、--"></a>自增自减：<code>++</code> 、<code>--</code></h3><p><code>a++</code>: 执行完这行代码之后，先赋值给<code>b</code>，然后再<strong>自增</strong></p><p><code>++a</code>: 执行这行代码<strong>之前</strong>，先<strong>自增</strong>，然后再给<code>c</code>赋值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;自增自减：&#96;++&#96; 、&#96;--&#96;int a &#x3D; 3;int b &#x3D; a++; System.out.println(a); &#x2F;&#x2F; 4System.out.println(b); &#x2F;&#x2F; 3int c &#x3D; ++a; &#x2F;&#x2F; c &#x3D; 5, a &#x3D; 5int d &#x3D; ++c + b + ++a + a++; &#x2F;&#x2F; c &#x3D; 6, b &#x3D; 3, ++a &#x3D; 6, a++ &#x3D; 6System.out.println(a); &#x2F;&#x2F; 7 (a++ 自增)System.out.println(b); &#x2F;&#x2F; 3System.out.println(c); &#x2F;&#x2F; 6System.out.println(d); &#x2F;&#x2F; 21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h3><p>幂运算可以使用java的工具类<code>Math</code>来运行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">double pow &#x3D; Math.pow(2, 3); &#x2F;&#x2F; 2的3次方System.out.println(pow); &#x2F;&#x2F; 8.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><code>&amp;&amp;</code>: 逻辑与(and)运算</li><li><code>||</code>: 逻辑或(or)运算</li><li><code>!</code>: 逻辑非(取反)运算</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">boolean a &#x3D; true;boolean b &#x3D; false;System.out.println(a &amp;&amp; b); &#x2F;&#x2F; falseSystem.out.println(a || b); &#x2F;&#x2F; trueSystem.out.println(!(a &amp;&amp; b)); &#x2F;&#x2F; true&#x2F;&#x2F;短路运算int c &#x3D; 5;boolean d &#x3D; (c &lt; 4) &amp;&amp; (c++ &lt; 4);System.out.println(d); &#x2F;&#x2F; falseSystem.out.println(c); &#x2F;&#x2F; 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p><a href="https://www.runoob.com/w3cnote/bit-operation.html">点这里到：菜鸟教程-位运算</a></p><p>从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算。</p><table><thead><tr><th align="left">符号</th><th align="left">描述</th><th align="left">运算规则</th></tr></thead><tbody><tr><td align="left"><code>&amp;</code></td><td align="left">与</td><td align="left">两个位都为1时，结果才为1</td></tr><tr><td align="left">|</td><td align="left">或</td><td align="left">两个位都为0是，结果才为0</td></tr><tr><td align="left"><code>^</code></td><td align="left">异或</td><td align="left">两个位相同为0，相异为1</td></tr><tr><td align="left"><code>~</code></td><td align="left">取反</td><td align="left">0变1，1变0</td></tr><tr><td align="left"><code>&lt;&lt;</code></td><td align="left">左移</td><td align="left">各二进位全部左移若干位，高位丢弃，低位补0</td></tr><tr><td align="left"><code>&gt;&gt;</code></td><td align="left">右移</td><td align="left">各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</td></tr></tbody></table><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">A &#x3D; 0011 1100B &#x3D; 0000 1101# A &amp; B -&gt; A与BA &amp; B &#x3D; 0000 1100# A | B -&gt; A或BA | B &#x3D; 0011 1101# A ^ B -&gt; A异或BA ^ B &#x3D; 0011 0010# ~A -&gt; 取反A~A &#x3D; 1100 0011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思考：在计算机运算<code>2 * 8</code>中，用什么方式效率最高？</p><ul><li>采用位运算是最快的。采用<code>&lt;&lt;</code>左移来实现。</li></ul><h3 id="字符串连接符"><a href="#字符串连接符" class="headerlink" title="字符串连接符"></a>字符串连接符</h3><p>在<code>+</code>的两边只要出现了<code>String</code>，就会把其他的字符都变成<code>String</code>类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int a &#x3D; 20;int b &#x3D; 30;System.out.println(a + b + &quot;&quot;); &#x2F;&#x2F; 输出结果为：50System.out.println(&quot;&quot; + a + b); &#x2F;&#x2F; 输出结果为：2030<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p><code>x ? y : z</code>这就是一个三元运算符。运行方式为：如果<code>x == ture</code> ，那么结果就为<code>y</code>，否则结果就为<code>z</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int score &#x3D; 80;String grades &#x3D; score &lt; 60 ? &quot;不及格&quot; : &quot;及格&quot;;System.out.println(grades); &#x2F;&#x2F;输出结果为：及格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在对照着视频把老师的知识点用博客这样的方式记录下来，这样不仅加深了这些知识的理解，同时也能更好的帮助我随时查阅。积少成多、聚沙成塔，只要坚持下来就没有什么搞不定的。</p><p>之后，我也会继续学习java，继续更新博客。分享知识、结交朋友，感谢你的观看！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>B站：<a href="https://www.bilibili.com/video/BV12J41137hu?p=30&share_source=copy_web">狂神说java</a></p><p>菜鸟教程：<a href="https://www.runoob.com/java/java-operators.html?_t_t_t=0.3133259497117251">java运算符</a></p><p>菜鸟教程：<a href="https://www.runoob.com/w3cnote/bit-operation.html">位运算</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学笔记 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记1 - java入门</title>
      <link href="/2021/07/07/java-xue-xi-bi-ji-1-java-ru-men/"/>
      <url>/2021/07/07/java-xue-xi-bi-ji-1-java-ru-men/</url>
      
        <content type="html"><![CDATA[<p>自用的学习笔记，若有错误欢迎指出。</p><h2 id="java的诞生"><a href="#java的诞生" class="headerlink" title="java的诞生"></a>java的诞生</h2><h3 id="C-amp-C"><a href="#C-amp-C" class="headerlink" title="C &amp; C++"></a>C &amp; C++</h3><ul><li>1972年C语言诞生<ul><li>贴近硬件，运行极快，效率极高。</li><li>操作系统，编译器，数据库，网络系统等等</li><li>指针和内存管理</li></ul></li><li>1982年C++诞生<ul><li>面向对象</li><li>兼容C</li><li>图形领域、游戏等等</li></ul></li></ul><h3 id="java初生"><a href="#java初生" class="headerlink" title="java初生"></a>java初生</h3><ul><li>设计理念：<ul><li>语法有点像C</li><li>没有指针</li><li>没有内存管理</li><li>真正的可移植性</li><li>面向对象</li><li>类型安全</li><li>高质量的类库</li></ul></li></ul><ul><li>由于1995年的互联网刚刚诞生，网页简单而且粗糙，缺乏互动性。</li><li>有人利用出java制作出图形界面的程序(Applet)，提高了用户体验，同时也吸引了很多商业巨头的眼光和好评。</li><li>java 2 标准版(J2SE): 桌面端</li><li>java 2 移动版(J2ME): 手机端</li><li>java 2 企业版(J2EE): 占领服务器</li><li>基于java开发了很多平台，系统，工具<ul><li>构建工具: Ant, Maven, Jekins</li><li>应用服务器: Tomcat, Jetty, Jboss, Websphere, weblogic</li><li>Web开发: Struts, Spring, Hibernate, myBatis</li><li>开发工具: Eclipse, Netbean, intellij idea, Jbuilder</li></ul></li><li>2006: Hadoop(大数据领域)</li><li>2008: Android(手机端)</li></ul><h2 id="java的特性和优势"><a href="#java的特性和优势" class="headerlink" title="java的特性和优势"></a>java的特性和优势</h2><ul><li>简单性</li><li>面向对象</li><li>可移植性</li><li>高性能</li><li>分布式</li><li>动态性</li><li>多线程</li><li>安全性</li><li>健壮性</li></ul><h2 id="java三大版本"><a href="#java三大版本" class="headerlink" title="java三大版本"></a>java三大版本</h2><ul><li>Write Once, Run Anywhere <ul><li>可移植性，JVM虚拟机来实现跨平台</li></ul></li><li>JavaSE: 标准版<ul><li>开发桌面程序，控制台开发</li></ul></li><li>JavaME: 嵌入式开发<ul><li>手机，小家电(现已不流行使用)</li></ul></li><li>JavaEE: E企业级开发<ul><li>web端，服务器开发</li></ul></li></ul><h2 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK, JRE, JVM"></a>JDK, JRE, JVM</h2><ul><li>JDK: Java Development Kit</li><li>JRE: Java Runtime Environment</li><li>JVM: Java Virtual Machine</li></ul><p>![三种JDK_JRE_JVM](./java学习笔记1 - java入门/三种JDK_JRE_JVM.png)</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学笔记 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOS基本指令</title>
      <link href="/2021/07/07/dos-ji-ben-zhi-ling/"/>
      <url>/2021/07/07/dos-ji-ben-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>自用的学习笔记，若有错误欢迎指出。</p><h2 id="基本的DOS指令"><a href="#基本的DOS指令" class="headerlink" title="基本的DOS指令"></a>基本的DOS指令</h2><h3 id="开启DOS控制台的几种方式"><a href="#开启DOS控制台的几种方式" class="headerlink" title="开启DOS控制台的几种方式"></a>开启DOS控制台的几种方式</h3><p>打开cmd的方式</p><ol><li>使用开始菜单栏 —&gt; 系统 —&gt; 命令提示符;</li><li>win键 + R，输入<code>cmd</code>打开控制台(推荐使用);</li><li>在任意文件夹下面，按住shift键+鼠标右键点击，在此处命令行窗口;</li><li>资源管理器的地址栏前面输入<code>cmd</code>路径;</li><li>鼠标右键在第一种方法那里的命令提示符，选择”以管理员身份运行”，可以得到计算机的最高权限;</li></ol><h3 id="常用的DOS命令"><a href="#常用的DOS命令" class="headerlink" title="常用的DOS命令"></a>常用的DOS命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#盘符切换E:#查看当前目录下的所有文件dir#切换目录cd &#x2F;d F:\study\xxx#返回上一级cd ..#清理屏幕cls#查看电脑的ipipconfig#打开应用calc #计算器notepad #记事本mspaint #画图工具#ping 命令ping www.baidu.com#文件操作##新建文件md test #新建了一个名为&quot;test&quot;的文件夹cd&gt;a.txt #新建了一个&quot;a.txt&quot;文件##删除文件del&gt;a.txt #删除掉刚刚新建的&quot;a.txt&quot;文件rd test #删除掉刚刚新建的&quot;test&quot;的文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOS </tag>
            
            <tag> Typora </tag>
            
            <tag> 自学笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客的搭建以及学习历程</title>
      <link href="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/"/>
      <url>/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/</url>
      
        <content type="html"><![CDATA[<p>温故而知新，可以为师矣。</p><p>对我来说，搭建自己的个人博客不仅仅是为了自己的兴趣爱好。同时，写博客也可以很好的记录下自己成长的每一个脚印。我们往往在一路再向前赶路，却忘了放慢脚步。放慢脚步来反思自己的不足，明白自己为何跌倒。这样我们才可以走得更远。</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>这一次我们搭建的博客是需要使用：</p><ul><li>Git</li><li>Hexo</li><li>Node.js</li></ul><h3 id="下载并安装Node-js"><a href="#下载并安装Node-js" class="headerlink" title="下载并安装Node.js"></a>下载并安装Node.js</h3><p>其中，我们需要在Node.js的官网上面下载Node.js的安装包。</p><p><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/Node.js_phase01.png" alt="Node.js_phase01"></p><p>一般我们选择正式版，正式版还是最稳定的版本。(使用最新版本可能会与教程的步骤有所出入)</p><p>一般在安装过程中点击next键按照默认的设置来就行。安装路径按照自己喜好来就行。</p><p>使用cmd面板来测试Node.js是否有安装成功。使用win键+R键来呼出cmd面板。输入node -v命令行来查看我们所安装的node的版本。出现版本号就证明我们已经安装好了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node -v #查看node版本npm -v #查看npm版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/cmd_node -v&npm -v.png" alt="cmd_node -v&npm -v" style="zoom:80%;"><p>由于我们国内有墙*<del>你懂的</del>*,导致一些镜像源上下载的很慢。所以，我们还需要来利用npm来安装cnpm。这样可以加快下载速度。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org #安装淘宝的cnpm 管理器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>耐心的等待之后就可以下载完成。</p><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/cmd_hexo_deployer_git.png" alt="cmd_hexo_deployer_git" style="zoom:80%;"><p>当我们输入cnpm后，出现反馈就说明我们的cnpm也已经安装好了。</p><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/cmd_cnpm_check.png" alt="cmd_cnpm_check" style="zoom:80%;"><h3 id="安装Hexo框架"><a href="#安装Hexo框架" class="headerlink" title="安装Hexo框架"></a>安装Hexo框架</h3><p>我们终于可以下载并且安装Hexo框架了。</p><p>在控制台输入代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cnpm install -g hexo-cli #安装hexo框架<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/cmd_hexo_download.png" alt="cmd_hexo_download" style="zoom:80%;"><p>输入代码hexo -v来查看安装的hexo框架版本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo -v #查看hexo版本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/cmd_hexo_v.png" alt="cmd_hexo_v" style="zoom:80%;"><p>使用代码mkdir blog来创建blog目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir blog #创建blog目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/cmd_mkdir_blog.png" alt="cmd_mkdir_blog" style="zoom:80%;"><p>如图所示，我们已经在目录下成功创建了一个blog文件夹。</p><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/pc_mkdir_blog.png" alt="pc_mkdir_blog" style="zoom: 67%;"><p>这里我不想把我的博客文件装在C盘，我把文件装在F盘</p><p>具体指令需要查看cmd的常用指令集合。<a href="https://blog.csdn.net/qq_33862644/article/details/81171521">点击这里查看</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;d F:study #跳转到其他硬盘的其他文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/cmd_cd.png" alt="cmd_cd" style="zoom:80%;"><p>使用cd blog来进入blog的根目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd blog #进入blog目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/cmd_cd_blog.png" alt="cmd_cd_blog" style="zoom:80%;"><h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><p>使用hexo init生成博客 初始化博客</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init #生成博客 初始化博客<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/cmd_hexo_init.png" alt="cmd_hexo_init" style="zoom:80%;"><p>随后我们就可以使用hexo s来启动博客的本地服务器，来正式的查看我们的网页了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo s #启动本地博客服务<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/cmd_hexo_s.png" alt="cmd_hexo_s" style="zoom:80%;"><p>随后在网页上输入网页链接 <a href="http://localhost:4000/">http://localhost:4000</a> 来查看我们的博客网页。</p><p>如图所示，我们已经有了基本自带样式的博客网页，我们所做的从搭建环境到初始化博客已经全部做完了。接下来，就是开始创建新的博客内容以及将我们的博客托管到GitHub网页上。</p><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/web_hexo_blogpage.png" alt="web_hexo_blogpage" style="zoom:80%;"><h2 id="创建新的博客内容"><a href="#创建新的博客内容" class="headerlink" title="创建新的博客内容"></a>创建新的博客内容</h2><p>既然有了博客的基本框架，那么我就该把我们所想要分享的内容放到博客网页上去。具体的步骤如下：</p><p>使用命令行hexo n“这是博客文章名字”来创建新的博客内容。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo n &quot;这是博客文章名字&quot; #创建新的文章 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/cmd_hexo_n.png" alt="cmd_hexo_n" style="zoom:80%;"><p>接下来我们就可以使用文本编辑工具Markdown来编辑我们的博文。这里我也推荐给大家一款很好用的软件<a href="https://www.typora.io/">Typora</a>.</p><p>待我们编辑完博文之后，我们就该将新的博文发布我们的网页里面。</p><p>先清理一下，然后再生成博文。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo c #清理一下hexo g #生成<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/cmd_hexo_g.png" alt="cmd_hexo_g" style="zoom:80%;"><h2 id="将博客部署到GitHub上"><a href="#将博客部署到GitHub上" class="headerlink" title="将博客部署到GitHub上"></a>将博客部署到GitHub上</h2><p>我们的博客不可能只能在本地localhost上查看，我们需要将我们所想分享的东西放到网上去，让更多的人所了解。</p><p>首先我们要先登录到<a href="https://github.com/">GitHub</a>上。</p><p>登录之后我们点击”Your repositories”，在选择新建一个存储库。</p><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/web_github_newRe.png" alt="web_github_newRe" style="zoom:80%;"><p>然后我们一定要在对存储库命名的时候一定要是你的昵称比如我们的就是：MingFang310.github.io </p><p>然后我们点击create就好</p><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/web_github.png" alt="web_github" style="zoom:80%;"><p>【重要】随后我们需要在博客的目录下安装git的部署插件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cnpm install --save hexo-deployer-git #在blog目录下安装git部署插件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/cmd_hexo_deployer_git.png" alt="cmd_hexo_deployer_git" style="zoom:80%;"><p>(我这边自己已经装过一遍了，初次安装的时候，等待一下就好)</p><p>同时我们也需要更改_config.yml文件的配置，这里我们用文本编辑器VSCode来打开该文件。</p><p>点击进去以后找到#Deployment并且修改代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy:  type: git repo: https:&#x2F;&#x2F;github.com&#x2F;YourGithubName&#x2F;YourGithubName.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>网站链接为你在GitHub上创建的存储库的链接</p><p><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/vscode_change_deployment.png" alt="vscode_change_deployment"></p><p>最后一步，也就是使用命令行hexo d 对该博客部署到GitHub上面。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo d#部署到远程Github仓库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后我们就可以直接用我们GitHub网页链接的后半段直接访问我们的博客了！</p><p><img src="/2021/07/05/ge-ren-bo-ke-de-da-jian-yi-ji-xue-xi-li-cheng/web_blog_link.png" alt="web_blog_link"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><p><a href="https://blog.csdn.net/xjm850552586/article/details/84101345">hexo引用本地图片无法显示:</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=15443300066182090076">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo:</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
